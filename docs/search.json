[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introdução à Filoinformática",
    "section": "",
    "text": "Prêambulo\nA sistemática filogenética é atualmente um campo científico em plena expansão. As etapas de desenvolvimento dessas pesquisas envolvem a utilização de diversos programas de computadores, muitas vezes sem interface gráfica com usuário, inclusive de linguagens de programação. O tempo de aprendizagem desses programas pode variar dependendo do nível de conhecimento individual em informática. Nesse sentido, o presente curso poderá contribuir para a aceleração do processo de aprendizagem, ao mesmo tempo em que demonstra uma visão geral de todos os processos de uma análise filogenética com dados moleculares.",
    "crumbs": [
      "Prêambulo"
    ]
  },
  {
    "objectID": "all.html",
    "href": "all.html",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "",
    "text": "Prática\nO alinhamento múltiplo de sequências é a etapa do reconhecimento das homologias moleculares, isto é, a inferência da homologia primária molecular. Essa etapa pode ser executada através de diversos aplicativos, tais quais: Geneious, BioEdit, CodonCode Aligner.\nExistem diversos algoritmos de alinhamento são utilizados, como: Clustal, T-Coffee, MergeAlign, Muscle.\nApós o alinhamento múltiplo automático de sequências, dá-se início ao alinhamento manual. O alinhamento manual é necessário para garantir um alinhamento perfeito na matriz de dados. Cada coluna representa um caráter homólogo, cuja posição será comparada entre todos os terminais.\nO BioEdit v.7.0.5.3 Hall (1999) é um programa open-source bem conhecido para realização do alinhamento manual, mas seu desenvolvimento foi descontinuado. Não obstante, atualmente ainda é bastante utilizado.\nGeralmente, as extremidades do alinhamento são cortadas (trim, em inglês) durante a preparação da matriz final de caracteres.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#prática",
    "href": "all.html#prática",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "",
    "text": "Alinhamento múltiplo (automático)\nPara realizar o alinhamento, vamos utilizar o programa Geneious. Felizmente, esse programa executa a função de alinhamento mesmo em seu uso restrito, isto é, sem uma licença adquirida. O algoritmo próprio do programa costuma apresentar resultados bem satisfatórios.\nPortanto, abra todas as sequências consenso montadas no Geneious e execute o alinhamento múltiplo utilizando o algoritmo do próprio programa. Salve o alinhamento como alinhamento.fasta.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#sic",
    "href": "all.html#sic",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "SIC",
    "text": "SIC\nBinário",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#mcic",
    "href": "all.html#mcic",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "MCIC",
    "text": "MCIC\nMultiestados",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#prática-1",
    "href": "all.html#prática-1",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Prática",
    "text": "Prática",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#prática-regex-2",
    "href": "all.html#prática-regex-2",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Prática: RegEx 2",
    "text": "Prática: RegEx 2\nO arquivo .nex resultante do procedimento de codificação do SeqState precisa ser aberto em um editor de texto mais especializado para programação. Experimente o Notepad2.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#as-6-substituições",
    "href": "all.html#as-6-substituições",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "As 6 substituições",
    "text": "As 6 substituições\n(Holmes2001?)\n\n\nSubstituições do tipo transição são mais frequentes que transversões.\n\nTransição:\n\nEntre purinas: adenina (A) e guanina (G);\nEntre pirimidinas: citosina (C) e timina (T).\n\nTransversões:\n\nEntre purinas e pirimidinas.\n\n\nAdemais, as mutações silenciosas são mais frequentes do que:\n\nMutações de sentido errado (missense) ou não sinônimas;\n\nResulta na substituição de um aminoácido por outro.\n\nMutações sem sentido (nonsense).\n\nOcorre um substituição de um par de nucleotídeos dentro de uma região codificante de proteína que muda um códon para um aminoácido em um códon de término.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#modelo-jukescantor-jc-1969",
    "href": "all.html#modelo-jukescantor-jc-1969",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Modelo Jukes/Cantor (JC) 1969",
    "text": "Modelo Jukes/Cantor (JC) 1969\n\nAssume que as bases ocorrem com igual frequência e a taxa de substituição de uma base para qualquer outra é a mesma.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#modelo-kimura-k80-1980",
    "href": "all.html#modelo-kimura-k80-1980",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Modelo Kimura (K80) 1980",
    "text": "Modelo Kimura (K80) 1980\n\nReferido como “modelo de dois parâmetros de Kimura”\nAssume frequências distintas para transições e transversões",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#modelo-hasegawa-kishino-yano-hky-1985",
    "href": "all.html#modelo-hasegawa-kishino-yano-hky-1985",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Modelo Hasegawa-Kishino-Yano (HKY) 1985",
    "text": "Modelo Hasegawa-Kishino-Yano (HKY) 1985\n\nDistingue entre a taxa de transições e transversões (usando o parâmetro κ), e permite frequências de base desiguais.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#modelo-general-time-reversible-gtr-1986",
    "href": "all.html#modelo-general-time-reversible-gtr-1986",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Modelo General Time Reversible (GTR) 1986",
    "text": "Modelo General Time Reversible (GTR) 1986\n\nModelo de substituição mais utilizado.\nModelo mais neutro, independente, de sítios finitos e reversível no tempo\nTodos seis tipos de substituição têm taxas diferentes",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#ms-dos",
    "href": "all.html#ms-dos",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "MS-DOS",
    "text": "MS-DOS\n\nDiversos programas de análises filogenéticas foram desenvolvidos para o ambiente do DOS (Disk Operating System).\nO prompt de comando do DOS shell é representado por C:\\&gt;.\n\nA letra C refere-se à unidade de disco;\nOs dois-pontos e a contra-barra indicam o caminho do diretório-raiz da unidade C.\n\n\n\nSeleção do driver\n\nc:\n\nAcessa um diretório a partir do diretório atual:\n\ncd [diretório]\n\nRetorna um diretório:\n\ncd..\n\nRetorna ao diretório-raiz da unidade de disco:\n\ncd/\n\nAcessa um diretório:\n\ncd/[diretório]\n\nExibe os diretórios e arquivos locais:\n\ndir\n\n…, lado a lado:\n\ndir/w\n\n…, pausadamente:\n\ndir/p\n\n…, lado a lado, pausadamente:\n\ndir/w/p\n\nMostra todos os arquivos com determinada extensão:\n\ndir *.[extensão]\n\nMostra os argumentos da função dir:\n\ndir/?",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#iq-tree",
    "href": "all.html#iq-tree",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "IQ-TREE",
    "text": "IQ-TREE\n\nO IQ-TREE é um dos programas mais utilizados para condução de análises filogenéticas baseada no método da Máxima verossimilhança.\nVeja o Manual\nA primeira versão foi lançada em 2011. O IQ-Tree é o sucessor dos softwares IQPNNI (desde 2004) e do TREE-PUZZLE (desde 1995).\n\n\n\nPrática\n\nVamos testar o IQ-TREE utilizando o exemplo embutido no programa:\n\n\n\nColoque os arquivo com a matriz alinhada no mesmo diretório que o programa IQ-Tree. Isso evita que se tenha de especificar o caminho do arquivo a ser lido (input).\nRealize uma análise-teste com o exemplo do próprio programa, o arquivo example.phy, mas antes abra-o em um editor de texto plano (como o Bloco de Notas do Windows) para verificar seu conteúdo.\nEm seguida, execute os comandos abaixo:\n\nLista completa de funções do programa\n\niqtree -h\n\nInferir a árvore de máxima verossimilhança utilizando o melhor modelo selecionado pelo ModelFinder\n\niqtree -s example.phy\n\nExecutar apenas a busca pelo melhor modelo utilizando o ModelFinder\n\niqtree -s example.phy -m MF\n\nExecutar diferentes métodos para estimação do suporte dos ramos\n\niqtree -s example.phy -alrt 10000 -bb 10000 -lbp 10000 -abayes\n\n\n\nExemplo com dados particionados (matriz combinada)\n\nArquivo input\n\niqtree -spp mimosa.nex\n\nReescrever os arquivos, apagando os dados previamente gerados\n\niqtree -spp mimosa.nex -redo\n\nSeleção do terminal externo\n\niqtree -spp mimosa.nex -redo -o Mimosa_invisa_invisa\n\nMétricas de suporte dos ramos\n\niqtree -spp mimosa.nex -redo -o invisa_invisa -allnni -alrt 10000 -bb  10000 -lbp 10000 -abayes -bnni\n\nEstabelecendo constraints\n\niqtree -spp mimosa.nex -redo -o invisa_invisa -g mimosa.constr1\n\nConcatenar arquivos\n\ntype mimosa0.nex.treefile mimosa1.nex.treefile mimosa2.nex.treefile mimosa3.nex.treefile &gt; mimosa.treels\n\nExecutar os testes de topologia\n\niqtree -spp mimosa.nex -z mimosa.treels -o invisa_invisa -allnni -alrt 10000 -bb 10000 -abayes -lbp 10000 -bsam GENESITE -zb 10000 -au -zw",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#splitstree6",
    "href": "all.html#splitstree6",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "SplitsTree6",
    "text": "SplitsTree6\n\nPrática\n\nO arquivo .splits.nex gerado pelo IQ-TREE pode ser carregado pelo SplitsTree6 Huson e Bryant (2005), um programa com interface gráfica com usuário e simples de usar.\nDiferentemente das árvores filogenéticas, as redes filogenéticas conseguem representar as incongruências e incertezas do conjunto total de árvores obtidas na análise filogenética, e são produzidas a partir de métodos de distância específicos. Trata-se de uma ferramenta exploratória interessante que tem sido utilizada até mesmo fora do campo da biologia comparativa.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#mrbayes",
    "href": "all.html#mrbayes",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "MrBayes",
    "text": "MrBayes\n\nA primeira versão do MrBayes Huelsenbeck e Ronquist (2001) foi lançada em 2000. Este talvez seja o mais conhecido programa de análise bayesiana para filogenias.\nO MrBayes possui um console próprio onde são inseridas as linhas de comando.\n\n\n\nO ideal é manter o arquivo da matriz de dados a ser analisada no mesmo diretório do MrBayes.\n\n\nPrática 1\n\nAbra o MrBayes e execute os comandos abaixo:\n\nSobre o programa:\n\nabout\n\nCitações dos diferentes módulos do programa:\n\ncitations\n\nGera um arquivo .txt com a referência completa das funções no diretório Documents:\n\nmanual\n\nExibe as principais funções do programa:\n\nhelp\n\n\nCom a função “help” os diversos parâmetros são exibidos:\n\nExibe explicação e os parâmetros do modelo de verossimilhança:\n\nhelp lset\n\nExibe explicação e os parâmetros a prioris do modelo filogenético:\n\nhelp prset\n\nExibe explicação e os parâmetros da análise MCMC:\n\nhelp mcmc\n\nExibe explicação e os parâmetros da função sump:\n\nhelp sump\n\nExibe explicação e os parâmetros da função sumt:\n\nhelp sumt\n\n\nExecute uma análise filogenética utilizando o exemplo trazido pelo próprio MrBayes, o arquivo primatex.nex:\n\nCarrega dados do arquivo NEXUS\n\nexecute primates.nex\n\nAltera o modelo evolutivo para GTR+G+I (Variação na taxa de substituição entre sítios de nucleotídeos proporção de sítios invariáveis)\n\nlset nst 6 rates=invgamma\n\nConferir os parâmetros do modelo\n\nshowmodel\n\nPara alterar os parâmetros do modelo, use prset, indique o nome do parâmetro, insira o símbolo de igual “=”, e indique o valor\n\nprset\n\nInicia a análise Monte Carlo via cadeias de Markov alterando alguns parâmetros\n\nmcmc ngen=20000 samplefreq=100 printfreq=100 diagnfreq=1000\n\nResume os valores dos parâmetros usando o mesmo burn-in que o diagnóstico no comando “mcmc”\n\nsump\n\nResume as árvores usando o mesmo burn-in que o comando mcmc\n\nsumt\n\n\n\n\n\nPrática 2: Modelo de substituição\n\nPara especificação do modelo evolutivo, use o comando lset\nOs parâmetros de modelo mais utilizads são:\n\nnúmero de tipos de substituição\n\n\n1 = Jukes-Cantor\n2 = HKY\n6 = GTR\n\n\nmodelo de variação de taxa entre sítios (sites)\n\n\nI = Taxas de sítios invariáveis\nG = Taxas de distribuição gama entre os sítios\nI+G = Combinação\n\nPara configurar o modelo GTR+G, use:\n\n\nlset nst=6 rates=gamma\n\n\nPara configurar o modelo GTR+G+I, use:\n\n\nlset nst=6 rates=invgamma\n\n\nO modelo de GTR+I+G geralmente se ajusta melhor aos dados.\n\nFonte: http://treethinkers.org/tutorials/mrbayes\n\nNa versão mais recente do MrBayes (3.2.2) é possível evitar ter que especificar apenas um esquema de tipos de substituição, permitindo que MrBayes se mova por diferentes esquemas como parte de sua amostragem MCMC. Este procedimento é conhecido como salto reversível MCMC (RJ-MCMC).\nPara configurar o salto reversível, use o seguinte comando:\n\n\nlset nst=mixed rates=gamma\n\n\nO salto reversível não está configurado atualmente para diferentes modelos de variação de taxa entre sítios.\n\n\n\nPrática 3: Gerando o output\n\nDepois de executar uma análise MCMC no MrBayes, certifique-se de que as cadeias de Markov convergiram através do software Tracer.\nExclua as amostras influenciadas pelo ponto de partida de uma análise MCMC através de um processo conhecido como descarte do burn-in.\nA remoção do burn-in é feita especificando um valor para o parâmetro burnin de sump e sumt:\n\n\nsump burnin=1000\n\n\n\nsumt burnin=1000",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#softwares-para-seleção-de-modelos-evolutivos",
    "href": "all.html#softwares-para-seleção-de-modelos-evolutivos",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Softwares para seleção de modelos evolutivos",
    "text": "Softwares para seleção de modelos evolutivos",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#raxmlgui-2.0-jmodeltest-2",
    "href": "all.html#raxmlgui-2.0-jmodeltest-2",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "raxmlGUI 2.0 + jModelTest 2",
    "text": "raxmlGUI 2.0 + jModelTest 2\nhttps://antonellilab.github.io/raxmlGUI/\n\nPartitionFinder\nPartitionFinder  Os principais resultados são gravados no arquivo best_scheme.txt.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#prática-4",
    "href": "all.html#prática-4",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Prática",
    "text": "Prática\nNessa etapa, vamos utilizar o programa o FigTree para, em seguida, aprendermos o básico do  e seus pacotes de filogenia.\nAbra as árvores obtidas nas análises filogenéticas previamente executadas com o FigTree e experimente as possibilidades de edição.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#programação-orientada-a-objetos",
    "href": "all.html#programação-orientada-a-objetos",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Programação orientada a objetos",
    "text": "Programação orientada a objetos\n\nProgramação orientada a objetos.\nTudo no  são objetos.\nObjetos possuem uma estrutura de dados que armazenam variáveis.\nVariáveis armazenam valores ou conjunto de valores de acordo com o tipo dos dados\nAs variáveis populam estruturas de dados.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#principais-estruturas-de-dados",
    "href": "all.html#principais-estruturas-de-dados",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Principais estruturas de dados",
    "text": "Principais estruturas de dados\nAs variáveis são armazenadas em tipos de estruturas de dados:\n\nvetores\nlistas\nmatrizes\ndataframes\narrays\n\n\n\nFunções são também são objetos, mas executam um conjunto operações determinadas.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#principais-tipos-de-dados",
    "href": "all.html#principais-tipos-de-dados",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Principais tipos de dados",
    "text": "Principais tipos de dados\nAs váriáveis pode ser de diferentes tipos:\n\nnumeric\n\ninteger, double\n\ncharacter\n\nstring\n\nlogical\n\nTRUE, FALSE\n\nfactor\n\nvariáveis categóricas\nnº limitado de valores\nníveis do fator",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#classe-x-propriedade-x-atributo",
    "href": "all.html#classe-x-propriedade-x-atributo",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Classe x propriedade x atributo",
    "text": "Classe x propriedade x atributo\n\nTodo objeto tem uma classe.\n\nDiz-se que um objeto é uma instância de uma classe.\n\nUma classe contém propriedades.\n\nO valor que cada propriedade assume em um objeto é chamado de atributo.\n\n\n\n\n\n\n\nOutras classes podem ser definidas.\n\n\nSistema de referência\n\nNo R, há um sistema de referência de classes.\n\n\n\n\n\n\n\n\nClasse S3\nClasse S4\n\n\n\n\nAtributos são acessados usando $\nAtributos são acessados usando @",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#linguagem-r",
    "href": "all.html#linguagem-r",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Linguagem R",
    "text": "Linguagem R\n\nTudo após # não é lido pelo R. Este é um caractere de comentário.\nO  diferencia maiúsculas de minúsculas.\nHá uma série de operadores pré-programados.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#console",
    "href": "all.html#console",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Console",
    "text": "Console\n\nO console do  refere-se ao ambiente de desenvolvimento e o prompt de comando (command prompt) é a linha de inserção de comando. O símbolo no prompt de comando é o “&gt;”, porém ele também muda para “+” quando há a entrada de um comando incompleto. Com o sinal de +, o console indica que aguarda a completude do comando inserido.\nTudo após o símbolo “#” não é lido pelo R. Esse é o caráter para introdução de notas e comentários.\nO  diferencia maiúsculas de minúsculas.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#criando-objetos",
    "href": "all.html#criando-objetos",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Criando objetos",
    "text": "Criando objetos\nPara atribuir um valor a um objeto, utilize o operador &lt;- (ou =):\n\nx &lt;- 4\nx\n\n[1] 4\n\ny = 5\nx + y\n\n[1] 9",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#funções",
    "href": "all.html#funções",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Funções",
    "text": "Funções\n\nSintaxe da função\n\nfunção()\nfunção(argumento1 = valor, argumento2 = valor, ...)\n\nVamos criar uma função como exemplo:\n\nfunção &lt;- function(arg1 = \"\", arg2 = \"\"){\n  \n  Código_da_função\n  \n}\n\nVamos observar os argumentos da função com a função args()\n\nargs(função) # Mostra os argumentos da função `função`\n\nfunction (arg1 = \"\", arg2 = \"\") \nNULL\n\n\n\n\nFunções básicas\nVersão, licença e citação:\n\nR.Version() # mostra a versão\n\n$platform\n[1] \"x86_64-w64-mingw32\"\n\n$arch\n[1] \"x86_64\"\n\n$os\n[1] \"mingw32\"\n\n$crt\n[1] \"ucrt\"\n\n$system\n[1] \"x86_64, mingw32\"\n\n$status\n[1] \"\"\n\n$major\n[1] \"4\"\n\n$minor\n[1] \"2.2\"\n\n$year\n[1] \"2022\"\n\n$month\n[1] \"10\"\n\n$day\n[1] \"31\"\n\n$`svn rev`\n[1] \"83211\"\n\n$language\n[1] \"R\"\n\n$version.string\n[1] \"R version 4.2.2 (2022-10-31 ucrt)\"\n\n$nickname\n[1] \"Innocent and Trusting\"\n\nlicense() # informações sobre a licença\n\n\nThis software is distributed under the terms of the GNU General\nPublic License, either Version 2, June 1991 or Version 3, June 2007.\nThe terms of version 2 of the license are in a file called COPYING\nwhich you should have received with\nthis software and which can be displayed by RShowDoc(\"COPYING\").\nVersion 3 of the license can be displayed by RShowDoc(\"GPL-3\").\n\nCopies of both versions 2 and 3 of the license can be found\nat https://www.R-project.org/Licenses/.\n\nA small number of files (the API header files listed in\nR_DOC_DIR/COPYRIGHTS) are distributed under the\nLESSER GNU GENERAL PUBLIC LICENSE, version 2.1 or later.\nThis can be displayed by RShowDoc(\"LGPL-2.1\"),\nor obtained at the URI given.\nVersion 3 of the license can be displayed by RShowDoc(\"LGPL-3\").\n\n'Share and Enjoy.'\n\ncitation() # como citar\n\n\nTo cite R in publications use:\n\n  R Core Team (2022). R: A language and environment for statistical\n  computing. R Foundation for Statistical Computing, Vienna, Austria.\n  URL https://www.R-project.org/.\n\nA BibTeX entry for LaTeX users is\n\n  @Manual{,\n    title = {R: A Language and Environment for Statistical Computing},\n    author = {{R Core Team}},\n    organization = {R Foundation for Statistical Computing},\n    address = {Vienna, Austria},\n    year = {2022},\n    url = {https://www.R-project.org/},\n  }\n\nWe have invested a lot of time and effort in creating R, please cite it\nwhen using it for data analysis. See also 'citation(\"pkgname\")' for\nciting R packages.\n\n\nFunções de ajuda:\n\nhelp() # função ajuda\n\nstarting httpd help server ... done\n\nhelp.start() # Manuais e outros materiais\n\nIf nothing happens, you should open\n'http://127.0.0.1:27231/doc/html/index.html' yourself\n\nhelp(base) # Manual do pacote \"base\"\n\nFunções de data e hora:\n\nSys.time() # Obtém data e horário exatos do sistema\n\n[1] \"2025-04-27 11:06:09 -03\"",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#pacotes",
    "href": "all.html#pacotes",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Pacotes",
    "text": "Pacotes\nPacotes mais baixados:\n\n\n\n\n\n\n\n\nPacotes mais baixados em tempo real:",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#prática-5",
    "href": "all.html#prática-5",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Prática",
    "text": "Prática\n\nIndexação de objetos\n\nx &lt;- 4 # cria o objeto \"x\" atribuindo o valor \"4\"\nx # Observe o objeto criado\n\n[1] 4\n\n\nPara concatenar vários valores utilize a função c:\nConcatenar vários valores e atribuí-los a um objeto:\n\nx &lt;- c(4, 5, 6, 7, 8)\nx # Observe o objeto criado\n\n[1] 4 5 6 7 8\n\n\nExtrair um ou vários valores de um objeto a partir da indexação:\n\nx[3]\n\n[1] 6\n\nx[c(1, 4)]\n\n[1] 4 7\n\n\nSubstitua valores de um objeto a partir da indexação:\n\ny &lt;- c(24, 10, 45, 56, 20, 29, 50, 67, 80, 23, 20, 15, 65, 57, 34, 63, 20)\ny[y==20] &lt;- 10 # Se algum valor de y é igual a 20, substituir por 10\ny\n\n [1] 24 10 45 56 10 29 50 67 80 23 10 15 65 57 34 63 10\n\ny[y==10] &lt;- \"NA\" # Apaga todos os valores iguais a 10, substituindo por \"NA\"\ny\n\n [1] \"24\" \"NA\" \"45\" \"56\" \"NA\" \"29\" \"50\" \"67\" \"80\" \"23\" \"NA\" \"15\" \"65\" \"57\" \"34\"\n[16] \"63\" \"NA\"\n\n\nDeleta o objeto:\n\nrm(x)\n\nPode-se criar objetos com valores numéricos (numeric), conforme mostrado até aqui, mas também objetos com valores de caracteres (character), lógicos (logical) ou fatores (factor).\nObjetos do tipo character podem ser criados utilizando aspas (” “) entre os valores incluídos. Um objeto do tipo factor cria categorias para cada valor encontrado no objeto. Geralmente são usados em diversos pacotes para análises filogenéticas:\n\ncharacter &lt;-c(\"apical\", \"apical\", \"basal\", \"apical\", \"apical\", \"basal\", \"median\")\ncharacter\n\n[1] \"apical\" \"apical\" \"basal\"  \"apical\" \"apical\" \"basal\"  \"median\"\n\ncharact_fact &lt;- factor(character)\ncharact_fact\n\n[1] apical apical basal  apical apical basal  median\nLevels: apical basal median\n\n\n\n\nOperadores de lógica\n\n\n\n\n&lt; |\nless than |\n\n\n\n\n&lt;=\n| less than or equal to |\n\n\n\n\n\n\n&gt; |\ngreater than |\n\n\n\n\n&gt;=\n| greater than or equal to |\n\n\n\n\n\n\n== |\nexactly equal to |\n\n\n\n\n!= |\nnot equal to |\n\n\n\n\n\n\n!x |\nnot x |\n\n\n\n\nx |\ny | x OR y |\n\n\n\nx & y | x AND y | ——– ———\n\nVamos testar:\n\nx &lt;- c(1:10)\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nx[(x&gt;8) | (x&lt;5)]\n\n[1]  1  2  3  4  9 10\n\n# Qual a lógica?\nx &gt; 8\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n\nx &lt; 5\n\n [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\nx &gt; 8 | x &lt; 5\n\n [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE\n\nx[c(T, T, T, T, F, F, F, F, T, T)]\n\n[1]  1  2  3  4  9 10\n\n\nExperimente a utilização dos operadores matemáticos simples entre diferentes objetos:\n\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\ny\n\n [1] \"24\" \"NA\" \"45\" \"56\" \"NA\" \"29\" \"50\" \"67\" \"80\" \"23\" \"NA\" \"15\" \"65\" \"57\" \"34\"\n[16] \"63\" \"NA\"\n\n\n\n\nInspecionando os atributos um objeto\n\nobject.size(x) # Tamanho do objeto\n\n96 bytes\n\nstr(x) # Estrutura do objeto\n\n int [1:10] 1 2 3 4 5 6 7 8 9 10\n\nlength(x) # Comprimento\n\n[1] 10\n\nattributes(x) # Nomes, classes, etc\n\nNULL\n\nclass(x) # Tipo do objeto\n\n[1] \"integer\"\n\nmode(x) # Modo usado pelo R para armazenar objeto na memória\n\n[1] \"numeric\"\n\ntypeof(x) # Tipo usado pelo R para armazenar objeto na memória\n\n[1] \"integer\"\n\n\nInspecione os objetos criados. Exemplos:\n\nclass(x)\n\n[1] \"integer\"\n\nclass(y)\n\n[1] \"character\"\n\nclass(character)\n\n[1] \"character\"\n\nclass(charact_fact)\n\n[1] \"factor\"\n\n\n\n\nTeste e Coerção de objetos\nCom os métodos da função is é possível testar se um objeto corresponde a uma determinada classe. E com os métodos da função as é possível coagir um objeto de uma classe a transformar-se em outra.\nVeja os métodos das funções is e as: (Retire o operador # da frente do comando para rodá-lo)\n\nmethods(is)\n\nWarning in .S3methods(generic.function, class, envir): function 'is' appears\nnot to be S3 generic; found functions that look like S3 methods\n\n\n [1] is.array                is.atomic               is.call                \n [4] is.character            is.complex              is.data.frame          \n [7] is.double               is.element              is.empty.model         \n[10] is.environment          is.expression           is.factor              \n[13] is.finite               is.function             is.hashtab             \n[16] is.infinite             is.integer              is.language            \n[19] is.leaf                 is.list                 is.loaded              \n[22] is.logical              is.matrix               is.mts                 \n[25] is.na                   is.na.data.frame        is.na.numeric_version  \n[28] is.na.POSIXlt           is.na&lt;-                 is.na&lt;-.default        \n[31] is.na&lt;-.factor          is.na&lt;-.numeric_version is.name                \n[34] is.nan                  is.null                 is.numeric             \n[37] is.numeric.Date         is.numeric.difftime     is.numeric.POSIXt      \n[40] is.numeric_version      is.object               is.ordered             \n[43] is.package_version      is.pairlist             is.primitive           \n[46] is.qr                   is.R                    is.raster              \n[49] is.raw                  is.recursive            is.relistable          \n[52] is.single               is.stepfun              is.symbol              \n[55] is.table                is.ts                   is.tskernel            \n[58] is.unsorted             is.vector              \nsee '?methods' for accessing help and source code\n\n# methods(as)\n\nTeste com os objetos já criados:",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#rstudio",
    "href": "all.html#rstudio",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "RStudio",
    "text": "RStudio\nO RStudio é um Ambiente Interativo de Desenvolvimento (IDE) que traz o console R, um editor de script, a exibição dos objetos e funções do ambiente de trabalho, área de plotagem, entre outras funcionalidades e automatizações, dentre as quais:\n\nIdentação automática\nComplementação de parênteses\nEditor com destaque de sintaxe\nAuto-completar comandos",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#ambiente-de-trabalho",
    "href": "all.html#ambiente-de-trabalho",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Ambiente de Trabalho",
    "text": "Ambiente de Trabalho\n\nO ambiente de trabalho (workspace) é o espaço virtual onde os objetos definidos pelo usuário (vetores, matrizes, dataframes, listas, funções) são alocados.\nNo RStudio, podemos observar o ambiente de trabalho e seus objetos na aba Ènvironment.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#diretório-de-trabalho",
    "href": "all.html#diretório-de-trabalho",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Diretório de Trabalho",
    "text": "Diretório de Trabalho\n\nO diretório de trabalho (working directory) define o diretório-raiz do caminho de diretórios para fins de entrada e saída de arquivos. Ele define o caminho relativo para um caminho de diretórios.\nO caminho absoluto tem início na pasta raiz do seu disco local do computador. O caminho absoluto do ambiente de trabalho (workspace) pode ser obtido com a função getwd(). Abaixo vemos o diretório-raiz do presente bookdown no computador local:\n\n\ngetwd()\n\n[1] \"D:/gitRepositories/Introducao-a-Filoinformatica\"\n\n\n\n\nls() # lista todos os objetos/funções do Ambiente de Trabalho\n\n[1] \"charact_fact\"    \"character\"       \"função\"          \"pandoc_dir\"     \n[5] \"quarto_bin_path\" \"x\"               \"y\"              \n\nrm(list = ls()) # limpa todo Ambiente de Trabalho\n\nls() # lista todos os objetos/funções do Ambiente de Trabalho\n\ncharacter(0)",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#pacotes-de-filogenia",
    "href": "all.html#pacotes-de-filogenia",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Pacotes de filogenia",
    "text": "Pacotes de filogenia\n\nDiversos pacotes para filogenias têm sido desenvolvidos no R. Os pacotes mais importantes são: ape, geiger, ggtree, phangorn, phylobase, phyloch, phytools e treeio.\nO primeiro pacote desenvolvido para filogenia no  foi o ape, lançado em 2002. Nele, a classe phylo, utilizando o sistema S3, foi implementada. Essa classe acabou sendo adotada pela maioria dos pacotes que foram lançados em seguida, e se tornou um padrão.\nPosteriormente, em 2009, a classe phylo4d utilizando o sistema S4 foi implementada no pacote phylobase.\nAtualmente essas são as duas principais classes que armazenam árvores filogenéticas e outros dados associados.\nNão deixe de conferir o site do CRAN, que traz um resumo dos principais pacotes desenvolvidos para análises filogenética: [https://cran.r-project.org/web/views/Phylogenetics.html].",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#escrevendo-árvores-a-partir-de-uma-cadeia-de-texto",
    "href": "all.html#escrevendo-árvores-a-partir-de-uma-cadeia-de-texto",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Escrevendo árvores a partir de uma cadeia de texto",
    "text": "Escrevendo árvores a partir de uma cadeia de texto\nNotação parentética e o arquivo Newick\n\nFoi adotado em 26 de junho de 1986 numa reunião informal convocada por Joe Felsenstein a membros do comitê durante as reuniões da Sociedade para o Estudo da Evolução em Durham. James Archie, William H E Day Wayne Maddison Christopher Meacham F. James Rohlf e David Swofford.\nA razão do nome é que a segunda e última sessão do comitê se reuniu no restaurante Newick’s Lobster House em Dover, New Hampshire, EUA.\nA representação de árvores foi desenvolvida por Christopher Meacham em 1984 para os programas de plotagem de árvores que ele escreveu para o PHYLIP.\nVamos escrever a árvore a partir de uma cadeia de texto (string):\n\n\nlibrary(ape)\n\nstring.tree &lt;- \"(Taxon1, Taxon2, Taxon3);\"\nstring.tree &lt;- read.tree(text = string.tree)\nplot(string.tree)\n\n\n\n\n\n\n\nstring.tree &lt;- \"((Taxon3, Taxon2), Taxon1);\"\nstring.tree &lt;- read.tree(text = string.tree)\nplot(string.tree)\n\n\n\n\n\n\n\nstring.tree &lt;- \"((Taxon1, Taxon2), Taxon3);\"\nstring.tree &lt;- read.tree(text = string.tree)\nplot(string.tree)\n\n\n\n\n\n\n\n\n\nVamos aprender o passo-a-passo para criar árvores filogenéticas. Para criá-la, comece pelo final da árvore. Vamos usar a árvore filogenética das Monocotiledôneas como exemplo. Observe a construção da árvore passo-a-passo:\n\nEscrevendo árvores através da notação parentética:\n\n“(Zingiberales, Commelinales);” “((Zingiberales, Commelinales), Poales);” “(((Zingiberales, Commelinales), Poales), Arecales);” “((((Zingiberales, Commelinales), Poales), Arecales),(Asparagales, Petrosaviales));” “(((((Zingiberales, Commelinales), Poales), Arecales),(Asparagales, Petrosaviales)), Liliales);” “((((((Zingiberales, Commelinales), Poales), Arecales),(Asparagales, Petrosaviales)), Liliales),(Pandanales, Dioscoriales));” “(((((((Zingiberales, Commelinales), Poales), Arecales),(Asparagales, Petrosaviales)), Liliales),(Pandanales, Dioscoriales)), Alismatales);” “((((((((Zingiberales, Commelinales), Poales), Arecales),(Asparagales, Petrosaviales)),Liliales),(Pandanales, Dioscoriales)), Alismatales), Acorales);” Execute cada bloco no console R, para exibir as topologias, uma de cada vez:\n\n\nMonocots &lt;- \"(Zingiberales, Commelinales);\"\nMonocots &lt;- read.tree(text = Monocots)\nplot(Monocots)\n\n\n\n\n\n\n\nMonocots &lt;- \"((Zingiberales, Commelinales), Poales);\"\nMonocots &lt;- read.tree(text = Monocots)\nplot(Monocots)\n\n\n\n\n\n\n\nMonocots &lt;- \"(((Zingiberales, Commelinales), Poales), Arecales);\"\nMonocots &lt;- read.tree(text = Monocots)\nplot(Monocots)\n\n\n\n\n\n\n\nMonocots &lt;- \"((((Zingiberales, Commelinales), Poales), Arecales),(Asparagales, Petrosaviales));\"\nMonocots &lt;- read.tree(text = Monocots)\nplot(Monocots)\n\n\n\n\n\n\n\nMonocots &lt;- \"(((((Zingiberales, Commelinales), Poales), Arecales),(Asparagales, Petrosaviales)), Liliales);\"\nMonocots &lt;- read.tree(text = Monocots)\nplot(Monocots)\n\n\n\n\n\n\n\nMonocots &lt;- \"((((((Zingiberales, Commelinales), Poales), Arecales),(Asparagales, Petrosaviales)),Liliales),(Pandanales, Dioscoriales));\"\nMonocots &lt;- read.tree(text = Monocots)\nplot(Monocots)\n\n\n\n\n\n\n\nMonocots &lt;- \"(((((((Zingiberales, Commelinales), Poales), Arecales),(Asparagales, Petrosaviales)), Liliales),(Pandanales, Dioscoriales)), Alismatales);\"\nMonocots &lt;- read.tree(text = Monocots)\nplot(Monocots)\n\n\n\n\n\n\n\nMonocots &lt;- \"((((((((Zingiberales, Commelinales), Poales), Arecales),(Asparagales, Petrosaviales)), Liliales),(Pandanales, Dioscoriales)), Alismatales), Acorales);\"\nMonocots &lt;- read.tree(text = Monocots)\nplot(Monocots)\n\n\n\n\n\n\n\n\nImporte também a árvore das Embriófitas:\n\nplants.tree &lt;- \"((((((((((((((Eudicots), Monocots), Magnoliids), Chloranthales), Autrobaileyales), Nymphaeales), Amborellales),((((Gnetales, Conifers), Gingkoales), Cycadales))),(((Sphenophytes, Marattiales), Filicales),(Ophioglossaceae, Psilophytes))),(Selaginellales, Lycopodiales)),(Bryophyta)),(Anthocerophyta)),(Marchantiophyta)));\"\nplants.tree &lt;- read.tree(text = plants.tree)\nplot(plants.tree)\n\n\n\n\n\n\n\n\nInspecione os objetos de classe phylo criados:\n\nstr(Monocots)\n\nList of 3\n $ edge     : int [1:20, 1:2] 12 13 14 15 16 17 18 19 19 18 ...\n $ Nnode    : int 10\n $ tip.label: chr [1:11] \"Zingiberales\" \"Commelinales\" \"Poales\" \"Arecales\" ...\n - attr(*, \"class\")= chr \"phylo\"\n - attr(*, \"order\")= chr \"cladewise\"\n\nstr(plants.tree)\n\nList of 3\n $ edge     : int [1:46, 1:2] 22 23 24 25 26 27 28 29 30 31 ...\n $ Nnode    : int 26\n $ tip.label: chr [1:21] \"Eudicots\" \"Monocots\" \"Magnoliids\" \"Chloranthales\" ...\n - attr(*, \"class\")= chr \"phylo\"\n - attr(*, \"order\")= chr \"cladewise\"\n\nclass(Monocots)\n\n[1] \"phylo\"\n\ntypeof(plants.tree)\n\n[1] \"list\"\n\n\nCheque os componentes dos objetos criados utilizando o operador $:\n\nMonocots$edge\n\n      [,1] [,2]\n [1,]   12   13\n [2,]   13   14\n [3,]   14   15\n [4,]   15   16\n [5,]   16   17\n [6,]   17   18\n [7,]   18   19\n [8,]   19    1\n [9,]   19    2\n[10,]   18    3\n[11,]   17    4\n[12,]   16   20\n[13,]   20    5\n[14,]   20    6\n[15,]   15    7\n[16,]   14   21\n[17,]   21    8\n[18,]   21    9\n[19,]   13   10\n[20,]   12   11\n\nMonocots$tip.label\n\n [1] \"Zingiberales\"  \"Commelinales\"  \"Poales\"        \"Arecales\"     \n [5] \"Asparagales\"   \"Petrosaviales\" \"Liliales\"      \"Pandanales\"   \n [9] \"Dioscoriales\"  \"Alismatales\"   \"Acorales\"     \n\nMonocots$Nnode\n\n[1] 10\n\nplants.tree$edge\n\n      [,1] [,2]\n [1,]   22   23\n [2,]   23   24\n [3,]   24   25\n [4,]   25   26\n [5,]   26   27\n [6,]   27   28\n [7,]   28   29\n [8,]   29   30\n [9,]   30   31\n[10,]   31   32\n[11,]   32   33\n[12,]   33   34\n[13,]   34   35\n[14,]   35    1\n[15,]   34    2\n[16,]   33    3\n[17,]   32    4\n[18,]   31    5\n[19,]   30    6\n[20,]   29    7\n[21,]   28   36\n[22,]   36   37\n[23,]   37   38\n[24,]   38   39\n[25,]   39    8\n[26,]   39    9\n[27,]   38   10\n[28,]   37   11\n[29,]   27   40\n[30,]   40   41\n[31,]   41   42\n[32,]   42   12\n[33,]   42   13\n[34,]   41   14\n[35,]   40   43\n[36,]   43   15\n[37,]   43   16\n[38,]   26   44\n[39,]   44   17\n[40,]   44   18\n[41,]   25   45\n[42,]   45   19\n[43,]   24   46\n[44,]   46   20\n[45,]   23   47\n[46,]   47   21\n\nplants.tree$tip.label\n\n [1] \"Eudicots\"        \"Monocots\"        \"Magnoliids\"      \"Chloranthales\"  \n [5] \"Autrobaileyales\" \"Nymphaeales\"     \"Amborellales\"    \"Gnetales\"       \n [9] \"Conifers\"        \"Gingkoales\"      \"Cycadales\"       \"Sphenophytes\"   \n[13] \"Marattiales\"     \"Filicales\"       \"Ophioglossaceae\" \"Psilophytes\"    \n[17] \"Selaginellales\"  \"Lycopodiales\"    \"Bryophyta\"       \"Anthocerophyta\" \n[21] \"Marchantiophyta\"\n\nplants.tree$Nnode\n\n[1] 26",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#importando-árvores-nos-formatos-s3-e-s4",
    "href": "all.html#importando-árvores-nos-formatos-s3-e-s4",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Importando árvores nos formatos S3 e S4",
    "text": "Importando árvores nos formatos S3 e S4\n\nClasse phylo (S3)\nImportante saber que árvores importadas como classe S3. Primeiro, apenas uma árvore pode ser armazenada como um objeto classe S3. E apenas a topologia, o comprimento dos ramos e os nomes dos terminais são importados. Lembre-se que para acessar instâncias de objetos S3 é utilizado o operator cifrão “$”.\nUm objeto de classe phylo é uma lista com os seguintes componentes:\n\nEdge a two-column matrix where each row represents a branch (or edge) of the tree; the nodes and the tips are symbolized with integers; the n tips are numbered from 1 to n, and the m (internal) nodes from n+1 to n+m (the root being n + 1).\ntip.label a vector of mode character giving the labels of the tips; the order of these labels corresponds to the integers 1 to n in edge.\nNnode an integer value giving the number of nodes in the tree (m).\nedge.length (opcional) a numeric vector giving the lengths of the branches given by edge.\nnode.label (opcional) a vector of mode character giving the labels of the nodes (ordered in the same way than tip.label).\nroot.edge (optional) a numeric value giving the length of the branch at the root if it exists.\n\n\n\nClasse phylo4 e phylo4d (S4)\nPor outro lado, inúmeras árvores podem ser armazenadas como um objeto de classe S4. Além de guardar as mesmas informações dos objetos S3, também pode armazenar outros dados, tais quais o suporte dos ramos entre outras informações sobre os ramos, e caracteres específicos dos terminais. Para acessar as instâncias de objetos S4 utiliza-se o operator arroba “@”. Ambos os operatores são usados para acessar as instâncias de objetos S4, na ordem @ e $.\nA classe phylo4 armazena apenas árvores, enquanto a classe phylo4d armazena tanto árvores quanto outros dados associados, como um dataframe contendo dados sobbre os ramos e terminais.\n\n\nImportando do IQTree\n\nlibrary(treeio)\nlibrary(phytools)\nlibrary(ggtree)\nlibrary(ggplot2)\n\ntree &lt;- read.iqtree(\"files/trees/example.phy.contree\")\ntree@phylo &lt;- force.ultrametric(tree@phylo)\n\n***************************************************************\n*                          Note:                              *\n*    force.ultrametric does not include a formal method to    *\n*    ultrametricize a tree & should only be used to coerce    *\n*   a phylogeny that fails is.ultramtric due to rounding --   *\n*    not as a substitute for formal rate-smoothing methods.   *\n***************************************************************\n\ntree@data$bootstrap &lt;- as.numeric(tree@phylo$node.label)\ntree.plot &lt;- ggtree(tree, size = 3, aes(color = bootstrap))  +\n  scale_color_continuous(low = \"red\", high = \"blue\") +\n  geom_treescale(fontsize = 10, width = 0.01) +\n  geom_nodelab(aes(x = branch, label = round(bootstrap, 1)), vjust = -0.5, size = 10) +  \n  theme(legend.position= c(0.1, 0.8), legend.key.size = unit(1.5, \"cm\")) +\n  theme(legend.text = element_text(size  = 10)) +\n  theme(legend.title = element_text(size = 10)) +\n  geom_tiplab(size = 10, color = \"black\", hjust = 1)\n\ntree.plot\n\n\n\n\n\n\n\n\n\n\nImportando do MrBayes\n\nlibrary(treeio)\n\nfile &lt;- system.file(\"extdata/MrBayes\", \"Gq_nxs.tre\", package=\"treeio\")\ntree.mrbayes &lt;- read.mrbayes(file)\nplot(tree.mrbayes@phylo)",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#extraindo-clados",
    "href": "all.html#extraindo-clados",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Extraindo clados",
    "text": "Extraindo clados\nA função extract.clade() obtém uma árvore a partir de um determinado nó.\n\nVamos plotar a árvore das plantas:\n\n\nlibrary(ape)\n\nplants.tree &lt;- \"((((((((((((((Eudicots), Monocots), Magnoliids), Chloranthales), Autrobaileyales), Nymphaeales), Amborellales),((((Gnetales, Conifers), Gingkoales), Cycadales))),(((Sphenophytes, Marattiales), Filicales),(Ophioglossaceae, Psilophytes))),(Selaginellales, Lycopodiales)),(Bryophyta)),(Anthocerophyta)),(Marchantiophyta)));\"\n\nplants.tree &lt;- read.tree(text = plants.tree)\n\nplot(plants.tree)\n\n\n\n\n\n\n\n\n\nOs nomes dos terminais (tip labels) são numerados em ordem consecutiva começando do 1:\n\n\nplot(plants.tree)\ntiplabels()\n\n\n\n\n\n\n\n\n\nOs nós (nodes) são numerados em ordem consecutiva começando do número consecutivo ao número de terminais:\n\n\nlength(plants.tree$tip.label) + 1\n\n[1] 22\n\n\n\nVejam os rótulos (labels) dos nós:\n\n\nplot(plants.tree)\nnodelabels()\n\n\n\n\n\n\n\n\n\nVamos extrair os clados com base no número (rótulo) do nó:\n\n\ntree1 &lt;- extract.clade(phy = plants.tree, node = 29)\nplot(tree1)\n\n\n\n\n\n\n\n# Tente a seleção do nó interativamente\n# tree2 &lt;- extract.clade(plants.tree, interactive = T)\n# plot(tree2)\n\n\nAgora vamos importar a árvore do APG:\n\nImporte a árvore:\n\n\nlibrary(ape)\n\napg.tree &lt;- read.tree(\"./files/trees/apg.tree\")\n\n\nVamos extrair o clado das Lamiales:\n\n\ntree &lt;- extract.clade(phy = apg.tree, node = \"lamiales\")\nplot(tree)\nnodelabels(tree$node.label, frame = \"none\", cex = 0.7)\n\n\n\n\n\n\n\n\n\nVamos descobrir como localizar certa string no conjunto de rótulos dos nós.\n\nVamos procurar o: Clado das Fixadoras de Nitrogênio (clado CFN) FABA-ROSA-CUCU-FAGA\n\n\n\nnome &lt;- \"nitrogen\"\nindex_of_clades_found &lt;- grep(nome, apg.tree$node.label)\napg.tree$node.label[index_of_clades_found]\n\n[1] \"nitrogenfixing_to_COM\" \"nitrogenfixing\"       \n\n\n\nExtraia o clado:\n\n\ntree &lt;- extract.clade(phy = apg.tree, node = \"nitrogenfixing\")\nplot(tree)\nnodelabels(tree$node.label, frame = \"none\", cex = 0.7)",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#personalizando-o-estilo-da-árvore",
    "href": "all.html#personalizando-o-estilo-da-árvore",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Personalizando o estilo da árvore",
    "text": "Personalizando o estilo da árvore\nAgora que temos um conjunto de objetos de classe phylo e phylo4, vamos aprender a alterar o design das árvores utilizando alguns dos principais pacotes para filogenia. Vamos conhecer um pacote de cada vez.\n\nPacote ape\nO pacote ape\n\nManual\n\nPerceba que o pacote ape implementou um método para a função plot() do pacote graphics, o plot.phylo(). Então, desde que o objeto seja de classe phylo ou phylo4 (ou ainda phylo4d) não se faz necessário digitar “.phylo” depois de plot:\n\nplot(plants.tree, type = \"phylogram\") # Default\n\n\n\n\n\n\n\nplot(plants.tree, type = \"cladogram\")\n\n\n\n\n\n\n\nplot(plants.tree, type = \"fan\")\n\n\n\n\n\n\n\nplot(plants.tree, type = \"radial\")\n\n\n\n\n\n\n\n\nPara gerar uma árvore não-enraizada, utilize a função unroot() para retirar a raiz da árvore, e use o argumento type = “unrooted” e lab4ut = “axial” da função plot.phylo():\n\nplot(unroot(plants.tree), type = \"unrooted\", lab4ut = \"axial\")\n\n\n\n\n\n\n\n\nAltere a direção da árvore com argumento direction:\n\nplot(Monocots, direction = \"leftwards\")\n\n\n\n\n\n\n\nplot(Monocots, direction = \"upwards\")\n\n\n\n\n\n\n\nplot(Monocots, direction = \"downwards\")\n\n\n\n\n\n\n\n\nGire o ângulo da árvore com o argumento rotate.tree:\n\nplot(Monocots, type = \"fan\")\n\n\n\n\n\n\n\nplot(Monocots, type = \"fan\", rotate.tree = 50)\n\n\n\n\n\n\n\n\nAbra o ângulo da árvore com argumento open.angle:\n\nplot(plants.tree, type = \"fan\")\n\n\n\n\n\n\n\nplot(plants.tree, type = \"fan\", open.angle = 180)\n\n\n\n\n\n\n\n\nAltere a direção os nomes dos terminais (tip.label) com o argumento lab4ut como “horizontal”:\n\nplot(Monocots, type = \"fan\", lab4ut=\"horizontal\")\n\n\n\n\n\n\n\n\nAltere o tamanho da árvore com os argumentos x.lim e y.lim:\n\nplot(plants.tree, x.lim = 25, y.lim = 22)\n\n\n\n\n\n\n\nplot(plants.tree, x.lim = 100, y.lim = 22)\n\n\n\n\n\n\n\nplot(plants.tree, x.lim = 150, y.lim = 22)\n\n\n\n\n\n\n\nplot(plants.tree, x.lim = 200, y.lim = 30)\n\n\n\n\n\n\n\nplot(plants.tree, x.lim = 250, y.lim = 30)\n\n\n\n\n\n\n\n\nPara executar diversas alterações, mudanças de estilos e anotações na árvore, é preciso saber qual o número associado a cada ramo e aos terminais. Para descobrir esses números usaremos as funções edgelabels(), tiplabels e nodelabels():\n\nplot(Monocots)\nedgelabels()\ntiplabels()\n\n\n\n\n\n\n\nplot(Monocots)\nnodelabels()\n\n\n\n\n\n\n\n\n\nRamos\nAltere a espessura dos ramos da árvore com o argumento edge.width: (default: 1)\n\nplot(plants.tree, edge.width = 3)\n\n\n\n\n\n\n\n\nAltere o formato da linha correspondente aos ramos com o argumento edge.lty (de 1 a 6): (Default: 1)\n\nplot(plants.tree, edge.lty = 2)\n\n\n\n\n\n\n\n\nAltere a cor dos ramos da árvore com argumento edge.color: (Default: 1)\n\nplot(plants.tree, edge.color = \"blue\")\n\n\n\n\n\n\n\nplot(plants.tree, edge.color = c(\"blue\", \"red\"))\n\n\n\n\n\n\n\nplot(plants.tree, edge.color = c(\"blue\", \"red\", \"yellow\"))\n\n\n\n\n\n\n\nplot(plants.tree, edge.color = 0) # 0 = sem cor\n\n\n\n\n\n\n\nplot(plants.tree, edge.color = 5)\n\n\n\n\n\n\n\n\nAltere a cor dos ramos selecionados da árvore com função def. A função def gera um vetor com os nomes dos terminais (tip.label):\n\nplot(plants.tree)\nnodelabels()\n\n\n\n\n\n\n\ndef1 &lt;- def(plants.tree$edge, `30` = \"blue\", `31` = \"blue\", `32` = \"blue\", `33` = \"blue\",\n    `34` = \"blue\", `35` = \"blue\")\nplot(plants.tree, edge.color = def1)\n\n\n\n\n\n\n\n\nA função def() pode ser utilizada com qualquer outro argumento da função plot.phylo(), mas teremos de indicar o estado de cada um dos nós nodelabels). Vamos repetir o código acima, no qual usamos a função def(), mas vamos incluir mais uma definição, a da espessura dos ramos. Perceba que ao criar o objeto def2 associamos a todos os números do nodelabels o número “1”, exceto os números 38, 39 e 40 que estão associados ao “3”:\n\nplot(plants.tree)\nnodelabels()\n\n\n\n\n\n\n\ndef2 &lt;- def(plants.tree$edge, `1` = 1, `2` = 1, `3` = 1, `4` = 1, `5` = 1, `6` = 1,\n    `7` = 1, `8` = 1, `9` = 1, `10` = 1, `11` = 1, `12` = 1, `13` = 1, `14` = 1,\n    `15` = 1, `16` = 1, `17` = 1, `18` = 1, `19` = 1, `20` = 1, `21` = 1, `22` = 1,\n    `23` = 1, `24` = 1, `25` = 1, `26` = 1, `27` = 1, `28` = 1, `29` = 1, `30` = 1,\n    `31` = 1, `32` = 1, `33` = 1, `34` = 1, `35` = 1, `36` = 1, `37` = 1, `38` = 3,\n    `39` = 3, `40` = 3, `41` = 1, `42` = 1, `43` = 1, `44` = 1, `45` = 1, `46` = 1,\n    `47` = 1, `47` = 1, `48` = 1, `49` = 1)\nplot(plants.tree, edge.width = def2, edge.lty = def2)\n\n\n\n\n\n\n\n\nAltere a cor dos ramos, ou outro parâmetro, com função rep() do pacote base:\n\nplot(plants.tree)\nedgelabels()\n\n\n\n\n\n\n\ncol &lt;- c(\"blue\", rep(\"red\", 2), rep(\"green\", 2), \"brown\", rep(\"black\", 14), rep(\"brown\",\n    8), rep(\"green\", 12), rep(\"red\", 6), \"blue\")\nplot(plants.tree, edge.color = col, edge.width = 4)\n\n\n\n\n\n\n\n\nPlote diferentes tipos de símbolos nos ramos da árvore com a função edgelabels(). Escolha o tipo de símbolo com o argumento pch, equivalente à função points do pacote graphics (veja essa função para descobrir os códigos dos símbolos, valores vão de 0 a 25). O argumento col altera a cor do símbolo. O argumento cex define o tamanho do símbolo (Default: 0). O argumento adj funciona como um eixo x e y para posição do símbolo:\n\nplot(plants.tree)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 0)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = -0.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 0.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = -1)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 1)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = -1.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 1.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 2)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 2.5)\n\n\n\n\n\n\n\n\n\n\nTerminais\nAumente a distância entre os nomes dos terminais (tip.label) e a árvore com o argumento label.offset: (experimente também outros valores diferentes de 1. (Default: 0)\n\nplot(Monocots, label.offset = 1)\n\n\n\n\n\n\n\n\nAltere a fonte dos terminais com argumento font (1: sem formato, 2: negrito, 3: italic, 4: negrito e itálico, etc): (Default: 3)\n\nplot(Monocots, font = 4)\n\n\n\n\n\n\n\n\nAltere o tamanho da fonte dos terminais com argumento cex: (Default: 1)\n\nplot(Monocots, cex = 0.5)\n\n\n\n\n\n\n\n\nAltere a justificação dos nomes dos terminais com argumento adj (de 0 a 1): (Default: 0)\n\nplot(Monocots, adj = 0.5)\n\n\n\n\n\n\n\nplot(Monocots, adj = 1)\n\n\n\n\n\n\n\n\nAltere a inclinação dos nomes dos terminais com argumento srt: (Default: 0)\n\nplot(plants.tree, srt = 25)\n\n\n\n\n\n\n\n\nAltere a cor da fonte do terminais com argumento tip.color: (Default: 1)\n\nplot(Monocots, tip.color = \"red\")\n\n\n\n\n\n\n\nplot(Monocots, tip.color = 0) # 0 = branco\n\n\n\n\n\n\n\nplot(Monocots, tip.color = 4)\n\n\n\n\n\n\n\n\nVamos usar a função def() para especificar as cores dos nomes dos terminais, e também, vamos alterar a fonte:\n\ndef3 &lt;- def(plants.tree$tip.label, Gnetales = \"blue\", Filicales = \"red\")\nplot(plants.tree, tip.color = def3)\n\n\n\n\n\n\n\ndef4 &lt;- def(plants.tree$tip.label, Gnetales = 2, Filicales = 4)\nplot(plants.tree, font = def4)\n\n\n\n\n\n\n\n\nVamos alterar a cor dos terminais usando função rep():\n\nplot(plants.tree)\ntiplabels()\n\n\n\n\n\n\n\nplot(plants.tree, tip.color = c(rep(\"red\", 7), rep(\"blue\", 4), rep(\"brown\", 5), rep(\"green\",\n    2), rep(\"black\", 3), \"yellow\"))\n\n\n\n\n\n\n\n\nInclua os nomes (tiplabels) apenas para determinados terminais:\n\nPrimeiro, selecione os números dos terminais:\n\n\nplot(plants.tree)\ntiplabels()\n\n\n\n\n\n\n\ni &lt;- c(4, 10, 17)\n\n\nDepois, vamos plotar a árvore sem os nomes dos terminais (show.tip.label = FALSE), introduzir um recuo com o argumento x.lim, e plotar os nomes dos terminais com a função tiplabels():\n\n\nplot(plants.tree, show.tip.label = FALSE, x.lim = 30)\ntiplabels(plants.tree$tip.label[i], i, adj = 0)\n\n\n\n\n\n\n\n\nRetire o quadro em volta do nome com o argumento frame = “none”:\n\nplot(plants.tree, show.tip.label = FALSE, x.lim = 30)\ntiplabels(plants.tree$tip.label[i], i, adj = 0, frame = \"none\")\n\n\n\n\n\n\n\n\nPlote diferentes tipos de símbolos terminais com a função tiplabels(). Com o argumento label.offset, afaste um pouco os nomes dos terminais da árvore:\n\nplot(plants.tree, label.offset = 1)\ntiplabels(tip = 1, pch = 20)\ntiplabels(tip = 2, pch = 19)\ntiplabels(tip = 3, pch = 18)\ntiplabels(tip = 4, pch = 17)\ntiplabels(tip = 5, pch = 16)\ntiplabels(tip = c(6,7), pch = c(15,14))\n\n\n\n\n\n\n\n\nUse também os argumentos cex, para aumentar ou diminuir o tamanho do símbolo, e adj, para afastar o símbolo na horizontal, da função tiplabels(); também altere a cor do fundo do símbolo com o argumento bg:\n\nplot(plants.tree, label.offset = 2.5)\ntiplabels(pch = 19, col = c(\"yellow\", \"red\", \"blue\"), adj = 1.4, cex = 1.5)\ntiplabels(pch = 21, bg = c(\"purple\",\"pink\",\"brown\"), adj = 2.4, cex = 1.5)\n\n\n\n\n\n\n\n\nPlote um símbolo nos terminais interativamente na área de plotagem: (Não esqueça de retirar o símbolo # da frente de cada linha)\n\n# f &lt;- function(col) {\n# o &lt;- identify(plants.tree)\n# tiplabels(tip=o$tips, pch = 19, col = col)\n# }\n# f(\"red\") # Clique no terminal para adicionar o símbolo\n# f(\"green\") # Faça o mesmo\n\n\n\nNós\nPlote os números associados aos nós com a função nodelabels():\n\nplot(plants.tree)\nnodelabels()\n\n\n\n\n\n\n\n\nEnraizar uma árvore com função root():\n\nplot(root(plants.tree, 4)) # Enraizando o nó número 4.\n\nWarning in min(x): no non-missing arguments to min; returning Inf\n\n\nWarning in max(x): no non-missing arguments to max; returning -Inf\n\n\n\n\n\n\n\n\n\nRotacionar uma árvore com função rotate():\n\nplot(plants.tree)\n\n\n\n\n\n\n\nplot(ape::rotate(plants.tree, 25))\n\n\n\n\n\n\n\n# OBS: O comando 'ape::rotate' é um chamamento específico da função rotate do\n# pacote ape. Portanto, os operadores '::' vindos após o nome de um pacote,\n# define a exata função do pacote. Isso é especialmente útil para não precisar\n# carregar o pacote inteiro ou quando existe duplicidade de nome de funções\n# entre pacotes distintos.\n\nPlote diferentes símbolos nos nós:\n\nplot(Monocots)\nnodelabels(pch = 20)\n\n\n\n\n\n\n\n\nPlote diferentes símbolos nos nós determinados:\n\nplot(plants.tree)\nnodelabels(node = 27, pch = 19)\nnodelabels(node = 28, pch = 20)\nnodelabels(node = 29, pch = 21)\n\n\n\n\n\n\n\n\nPlote um símbolo nos nós interativamente: (Retire os símbolos de # para rodar as linhas de comando)\n\n# f2 &lt;- function(col) {\n# o &lt;- identify(Monocots)\n# tiplabels(node=o$nodes, pch = 19, col = col)\n# }\n# f2(\"yellow\") # Clique no terminal para adicionar o símbolo\n# f2(\"blue\") # Faça o mesmo\n\n\n\n\nPacote phylocanvas\n\nlibrary(phylocanvas)\n\ntree &lt;- read.tree(text = \"(A:2, B:2, (C:1, D:1) E:1) F;\")\nphylocanvas(tree)\n\n\n\n\n\n\n\nPacote phytools\nO pacote phytools foi desenvolvido por Liam J. Revell.\n\n\nBlog oficial\nManual\n\nCarregue o pacote:\n\nlibrary(phytools)\n\nPlote a árvore com a função plotTree():\n\nplotTree(plants.tree)\n\n\n\n\n\n\n\n\nAltere o tipo de árvore com o argumento type (phylogram [Default]; fan; cladogram); o tamanho da fonte com o argumento fsize; e o estilo da fonte com ftype (reg = regular [default]; i = itálico; b = negrito; bi = itálico e negrito):\n\nplotTree(plants.tree, type = \"fan\", fsize = 1, ftype = \"i\", offset=1)\n\n\n\n\n\n\n\n\nPlote uma árvore com as bordas arredondadas com a função roundPhylogram:\n\nroundPhylogram(plants.tree)\n\n\n\n\n\n\n\n\nAplicar organização em escada nos clados com a função ladderize():\n\nplot(ladderize(plants.tree))\n\n\n\n\n\n\n\nplot(ladderize(plants.tree, FALSE))\n\n\n\n\n\n\n\n\nRotacione determinados nós com a função rotateNodes():\n\nrt.15 &lt;- rotateNodes(Monocots, 15)\nplotTree(rt.15, node.numbers = T)\n\n\n\n\n\n\n\n\nRotacionando toda a árvore:\n\nrt.all &lt;- rotateNodes(Monocots, \"all\")\nplotTree(rt.all, node.numbers = T)\n\n\n\n\n\n\n\n\nEnraize a árvore a partir de um determinado nó:\n\nrr.13 &lt;- root(Monocots, node = 13)\nplotTree(rr.13, node.numbers = T)\n\n\n\n\n\n\n\nrr.14 &lt;- root(Monocots, node = 14)\nplotTree(rr.14, node.numbers = T)\n\n\n\n\n\n\n\n\nEnraize a árvore interativamente: (Retire os operadores # da frente dos comandos)\n\n# rr.interactive &lt;- reroot(tree, interactive = TRUE)\n# plotTree(rr.interactive, node.numbers = T)\n\nCompare a topologia das árvores com a função all.equal():\n\n# A árvore rotacionada é igual à original?\nall.equal(Monocots, rt.all)\n\n[1] TRUE\n\n# A árvore reenraizada é igual à original?\nall.equal(Monocots, rr.13)\n\n[1] FALSE\n\n# As árvores original e reenraizada tornadas não-enraizadas são iguais:\nall.equal(unroot(Monocots), unroot(rr.13))\n\n[1] TRUE\n\n\nCorte uma árvore ao meio, plotando-a em duas colunas, com função splitplotTree. A função rcoal gera árvores aleatórias com número determinado de terminais:\n\ntrees &lt;- rcoal(50)\nsplitplotTree(trees)\n\n\n\n\n\n\n\n\n\nRamos\nAltere a espessura dos ramos com o argumento lwd:\n\nplotTree(Monocots, lwd = 3)\n\n\n\n\n\n\n\n\n\n\nTerminais\nPlote a árvore sem os terminais:\n\nplotTree(plants.tree, ftype = \"off\")\n\n\n\n\n\n\n\n\nAfaste os nomes dos terminais da árvore com o argumento offset:\n\nplotTree(plants.tree, offset = 1)\n\n\n\n\n\n\n\n\nDescobra o número dos terminais:\n\nspecies &lt;- c(\"Magnoliids\", \"Gingkoales\")\nts &lt;- sapply(species, grep, plants.tree$tip.label)\nts\n\nMagnoliids Gingkoales \n         3         10 \n\nplants.tree$tip.label[ts]\n\n[1] \"Magnoliids\" \"Gingkoales\"\n\n\nAdicione uma seta em determinados terminais:\n\nplotTree(plants.tree, type = \"fan\", offset=1)\nadd.arrow(plants.tree, tip = ts, arrl = 0.3, hedl = 0.1)\n\n\n\n\n\n\n\n\nRetire terminais determinados terminais:\n\ndrop.species &lt;- drop.tip(plants.tree, species)\nplotTree(drop.species, type = \"fan\", ftype = \"i\", offset=1)\n\n\n\n\n\n\n\n\n\n\n\nPacote ggtree\nO pacote ggtree\n\nManual\n\nCarregue os pacotes:\n\nlibrary(ggtree)\nlibrary(ggplot2)\n\nPlote a árvore com a função ggtree():\n\nggtree(plants.tree)\n\n\n\n\n\n\n\n\nEscolha o tipo de árvore com o argumento layout: (Default: “rectangular)\n\nggtree(plants.tree, layout = \"rectangular\")\n\n\n\n\n\n\n\nggtree(plants.tree, layout = \"slanted\") \n\n\n\n\n\n\n\nggtree(plants.tree, layout = \"circular\")\n\n\n\n\n\n\n\nggtree(plants.tree, layout = \"radial\")\n\n\n\n\n\n\n\nggtree(plants.tree, layout = \"equal_angle\")\n\n\n\n\n\n\n\nggtree(plants.tree, layout = \"daylight\")\n\nAverage angle change [1] 0.0706831962525389\n\n\nAverage angle change [2] 0.0231394088195458\n\n\n\n\n\n\n\n\nggtree(plants.tree, layout = \"fan\", open.angle = 120)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\n\n\nGire a árvore do tipo circular com a função rotate_tree():\n\nggtree(plants.tree, layout = 'circular')\n\n\n\n\n\n\n\nrotate_tree(ggtree(plants.tree, layout = 'circular'), 60)\n\nCoordinate system already present. Adding new coordinate system, which will\nreplace the existing one.\n\n\n\n\n\n\n\n\n\nAplicar a ordenação em escada (ladderize):\n\nggtree(plants.tree, ladderize = FALSE)\n\n\n\n\n\n\n\nggtree(plants.tree, ladderize = TRUE)\n\n\n\n\n\n\n\n\nAltere a cor do fundo com função theme_tree(). O operador + adiciona diferentes funções na mesma plotagem:\n\nggtree(plants.tree) + theme_tree()\n\n\n\n\n\n\n\nggtree(plants.tree) + theme_tree(bgcolor = \"gray\")\n\n\n\n\n\n\n\nggtree(plants.tree) + theme_tree(bgcolor = \"lightblue\")\n\n\n\n\n\n\n\n\nAltere a direção da árvore com as funções scale_x_reverse() e coord_flip() do pacote ggplot2:\n\nggtree(plants.tree) + scale_x_reverse()\n\n\n\n\n\n\n\nggtree(plants.tree) + coord_flip()\n\n\n\n\n\n\n\nggtree(plants.tree) + scale_x_reverse() + coord_flip()\n\n\n\n\n\n\n\n\nDefina o tamanho da árvore com a função coord_cartesian do pacote ggplot:\n\nggtree(plants.tree) + coord_cartesian(xlim = c(0, 50), ylim = c(0, 22))\n\n\n\n\n\n\n\n\nDefina o limite do eixo x com função xlim():\n\nggtree(plants.tree, layout='circular') + xlim(-20, 15)\n\n\n\n\n\n\n\n\nAdicionando escala com a função geom_treescale():\n\nggtree(plants.tree) + geom_treescale()\n\n\n\n\n\n\n\n\nAltere os parâmetros da escala com argumentos específicos:\n\nggtree(plants.tree) + geom_treescale(x = 1, y = 20, width = 1, color = 'red', fontsize = 4, linesize = 2, offset = 1)\n\n\n\n\n\n\n\n\n\nRamos\nColoque textos nos ramos:\n\nggtree(plants.tree) +\n  geom_text2(aes(x = branch, label = \"Eba!\"))\n\n\n\n\n\n\n\n\nAltere a cor da linha da árvore:\n\nggtree(plants.tree, color = \"firebrick\")\n\n\n\n\n\n\n\n\nAltere o tipo de linha da árvore: (Default: “solid”)\n\nggtree(plants.tree, lty = \"solid\")\n\n\n\n\n\n\n\nggtree(plants.tree, lty = \"dotted\")\n\n\n\n\n\n\n\nggtree(plants.tree, lty = \"dashed\")\n\n\n\n\n\n\n\nggtree(plants.tree, lty = \"dotdash\")\n\n\n\n\n\n\n\nggtree(plants.tree, lty = \"longdash\")\n\n\n\n\n\n\n\nggtree(plants.tree, lty = \"twodash\")\n\n\n\n\n\n\n\nggtree(plants.tree, lty = \"F1\")\n\n\n\n\n\n\n\n\nAltere a espessura da linha da árvore: (Default: 0)\n\nggtree(plants.tree, size = 2)\n\n\n\n\n\n\n\n\nAltere parâmetros estéticos dos ramos de acordo com os clados com a função groupClade():\n\nPrimeiro visualize os números dos nós:\n\n\nggtree(Monocots) + geom_text2(aes(subset=!isTip, label=node), hjust=-.3)\n\n\n\n\n\n\n\n\n\nSelecione o clado que terá suas configurações alteradas:\n\n\ngroup &lt;- groupClade(Monocots, .node=16)\n\n\nAltere a cor com o argumento color da função aes():\n\n\nggtree(group, aes(color=group))\n\n\n\n\n\n\n\n\n\nDefina a cor dos grupos com a função scale_color_manual() do pacote ggplot2:\n\n\nggtree(group, aes(color = group)) + scale_color_manual(values = c(\"black\", \"firebrick\"))\n\n\n\n\n\n\n\n\n\nAltere o tipo de linha com o argumento linetype da função aes():\n\n\nggtree(group, aes(linetype=group))\n\n\n\n\n\n\n\n\n\nDefina o tipo de linha com a função scale_linetype_manual() do pacote ggplot2:\n\n\nggtree(group, aes(linetype = group)) + scale_linetype_manual(values = c(3, 2))\n\n\n\n\n\n\n\n\n\nAltere a espessura da linha com o argumento size da função aes():\n\n\nggtree(group, aes(size = group))\n\nWarning: Using size for a discrete variable is not advised.\n\n\n\n\n\n\n\n\n\n\nDefina o tamanho da linha com a função scale_size_manual() do pacote ggplot2:\n\n\nggtree(group, aes(size = group)) + scale_size_manual(values = c(1, 1.5))\n\n\n\n\n\n\n\n\n\nAltere e defina a transparência da linha com o argumento alpha da função aes():\n\n\nggtree(group, aes(alpha=group)) + scale_alpha_manual(values = c(1/2,1/5))\n\n\n\n\n\n\n\n\n\nUtilize quantos clados forem necessários:\n\n\ngroup2 &lt;- groupClade(Monocots, .node = c(17, 20, 21))\nggtree(group2, aes(color = group, linetype = group, size = group))\n\n\n\n\n\n\n\n\nAdicione uma escala de cores contínuas com função scale_color_continuous() do pacote ggplot2:\n\n# ggtree(tree, aes(color = posterior)) + \n#  scale_color_continuous(low = \"green\", high = \"red\") +\n#  theme(legend.position = \"bottom\")\n\nAdicione barras com a maior densidade posterior (HPD) nos nós, usando um vetor do tipo ‘double’ (valor min-máx), com a função geom_range():\n\n# ggtree(beast_tree) + geom_tiplab() + geom_range(\"length_0.95_HPD\", color = 'red', size = 2, alpha = .5)\n\n\n\nTerminais\nAdicione os nomes dos terminais com a função geom_tiplab():\n\nggtree(plants.tree) + geom_tiplab() + coord_cartesian(xlim = c(0, 50), ylim = c(0, 22))\n\n\n\n\n\n\n\n\nAdicione os nomes dos terminais apenas para um dos clados marcados no objeto group criado na seção a cima:\n\nggtree(group) + geom_tiplab(aes(subset = (group == 1)))\n\n\n\n\n\n\n\nggtree(group) + geom_tiplab(aes(subset = (group == 0)))\n\n\n\n\n\n\n\n\nAdicione determinados nomes dos terminais:\n\nggtree(plants.tree) + geom_tiplab(aes(subset = (node %in% c(1, 2, 3, 4))))\n\n\n\n\n\n\n\nggtree(Monocots) + geom_tiplab(aes(subset = (node %in% c(1, 2, 3, 4))), color = c(\"blue\", \"red\", \"green\", \"pink\"))\n\n\n\n\n\n\n\n\nCrie grupos de terminais utilizando vetores com nomes dos terminais ou números com função groupOTU():\n\ngroupOTU(ggtree(plants.tree), c(\"Monocots\", \"Eudicots\")) + aes(color = group) + geom_tiplab()\n\n\n\n\n\n\n\ngroupOTU(ggtree(plants.tree), 1:5) + aes(color = group) + geom_tiplab()\n\n\n\n\n\n\n\ngroupOTU(ggtree(plants.tree), c(1:5,10)) + aes(color = group) + geom_tiplab()\n\n\n\n\n\n\n\n\nAltere alguns parâmetros estéticos dos nomes dos terminais com argumentos específicos:\n\nggtree(plants.tree) + geom_tiplab(offset = 0.5, col = \"blue\", size = 1.8) + coord_cartesian(xlim = c(0, 50), ylim = c(0, 22))\n\n\n\n\n\n\n\n\nAdicione os nomes dos terminais em árvores do tipo circular com função geom_tiplab2(), e veja a diferença entre a função geom_tiplab():\n\nggtree(plants.tree, layout = \"circular\") + geom_tiplab(offset = 0.5, size = 1.8)\n\n\n\n\n\n\n\nggtree(plants.tree, layout = \"circular\") + geom_tiplab2(offset = 0.5, size = 1.8)\n\n\n\n\n\n\n\n\nAdicione símbolos nos terminais com função geom_tippoint():\n\nggtree(plants.tree) + geom_tippoint()\n\n\n\n\n\n\n\n\nAltere o tipo do símbolo nos terminais com o argumento shape. A coloração dos símbolos com fundo colorido é definida com o argumento fill:\n\nggtree(plants.tree) + geom_tippoint(shape = 22, fill=\"red\")\n\n\n\n\n\n\n\n\nAdicione símbolos em um determinado terminal:\n\nggtree(Monocots) + geom_tippoint(aes(subset = node == 5))\n\n\n\n\n\n\n\n\nAdicionando nomes dos clados com função geom_cladelabel():\n\nggtree(Monocots) + geom_cladelabel(node = 17, label = \"Clade A\") + geom_cladelabel(node = 20, label = \"Clade B\") + coord_cartesian(xlim = c(0, 10), ylim = c(0, 12))\n\nWarning: The following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\n\n\n\n\n\n\n\n\n\nAltere parâmetros estéticos com argumentos específicos:\n\nggtree(Monocots) + geom_cladelabel(node = 17, label = \"Clade A\", align = T, color = 'red', angle = 45) + geom_cladelabel(node = 20, label = \"Clade B\", align = T, color = 'blue', angle = 45) + coord_cartesian(xlim = c(0, 10), ylim = c(0, 12))\n\nWarning: The following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\n\n\n\n\n\n\n\n\n\nColoque uma caixa em volta do nome do clado com argumento geom():\n\nggtree(Monocots) + geom_cladelabel(node = 17, label = \"Clade A\", geom = 'label', fill = 'lightblue') + geom_cladelabel(node = 20, label = \"Clade B\", geom = 'label', fill = 'lightgreen') + coord_cartesian(xlim = c(0, 10), ylim = c(0, 12))\n\nWarning: The following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\n\n\n\n\n\n\n\n\n\nAdicione uma barra com função geom_strip():\n\nggtree(Monocots) + geom_strip(2, 4, barsize = 2, color = 'red') + geom_strip(8, 6, barsize = 2, color = 'blue')\n\n\n\n\n\n\n\n\nDestaque clados com função geom_hilight():\n\ntree4 &lt;- pbtree(n = 50, scale = 100)\nggtree(tree4, layout=\"circular\") + geom_hilight(node = 72, fill = \"steelblue\", alpha = .6) + geom_hilight(node = 91, fill = \"darkgreen\", alpha = .6)\n\n\n\n\n\n\n\n\nDestaque clados com função geom_hilight_encircle():\n\n#ggtree(tree4, layout = \"circular\") + geom_hilight_encircle(node = 72) + geom_hilight_encircle(node = 91, fill = 'darkgreen')\n\nDestaque os clados com highlight interativamente: (Retire os operadores # da frente dos comandos)\n\n# p &lt;- ggtree(tree4)\n# cols &lt;- rainbow(5)\n# ggtree(tree)\n# for (i in 1:5) {\n#  p &lt;- p + geom_hilight(identify(p), fill=cols[i])\n#  print(p)\n# }\n\n\n\nNós\nAdicione os números dos nós com a função geom_text2():\n\nggtree(Monocots) + geom_text2(aes(subset = !isTip, label = node))\n\n\n\n\n\n\n\n\nAjuste a posição do dos números dos nós com os argumentos hjust e vjust:\n\nggtree(Monocots) + geom_text2(aes(subset = !isTip, label = node), hjust = 1.1, vjust = -.2)\n\n\n\n\n\n\n\n\nAdicione símbolos aos nós com função geom_nodepoint():\n\nggtree(Monocots) + geom_nodepoint()\n\n\n\n\n\n\n\n\nAdicione um símbolo em um determinado nó:\n\nggtree(Monocots) + geom_nodepoint(aes(subset = (node == 16)))\n\n\n\n\n\n\n\nggtree(Monocots) + geom_nodepoint(aes(subset = (node == c(16, 21))))\n\n\n\n\n\n\n\n\nAltere os parâmetros estéticos com argumentos específicos. O argumento alpha altera a transparência do símbolo:\n\nggtree(Monocots) + geom_nodepoint(color = \"#b5e521\", alpha = 1/4, size = 10)\n\n\n\n\n\n\n\n\nAdicione símbolos aos nós por clados com a já mencionada função groupClade():\nAdicione símbolos aos nós com função geom_point2(): (OBS: os símbolos também são adicionados nos terminais)\n\nggtree(Monocots) + geom_point2()\n\n\n\n\n\n\n\n\nRotacione todos os nós a partir de um dado nó com função rotate e a função pipe %&gt;%:\n\nggtree(Monocots) + geom_text2(aes(subset = !isTip, label = node)) + geom_tiplab()\n\n\n\n\n\n\n\nggtree(Monocots) %&gt;% ggtree::rotate(16) + geom_text2(aes(subset = !isTip, label = node)) + geom_tiplab()\n\n\n\n\n\n\n\n\nRotacione interativamente os nós: (Retire o operador # da frente dos comandos)\n\n# p &lt;- ggtree(plants.tree) + geom_tiplab() + coord_cartesian(xlim = c(0, 50), ylim = c(0, 22))\n# for (i in 1:10) {\n# p &lt;- p %&gt;% ggtree::rotate(identify(p))\n# print(p)\n# }\n\nRotacione apenas determinados nós-irmãos com a função flip():\n\nggtree(Monocots) + geom_text2(aes(subset = !isTip, label = node)) + geom_tiplab()\n\n\n\n\n\n\n\nflip(ggtree(Monocots), 17, 20) + geom_text2(aes(subset = !isTip, label = node)) + geom_tiplab()\n\n\n\n\n\n\n\n\nColapse nós com função colapse():\n\nggtree(Monocots) + geom_text2(aes(subset = !isTip, label = node), hjust = -.3) + geom_tiplab() + coord_cartesian(xlim = c(0, 10), ylim = c(0, 12))\n\n\n\n\n\n\n\nggtree(Monocots) %&gt;% collapse(17) + geom_text2(aes(subset = !isTip, label = node), hjust = -.3) + geom_tiplab() + coord_cartesian(xlim = c(0, 10), ylim = c(0, 12))\n\n\n\n\n\n\n\n\nIntroduza um símbolo em um nó colapsado:\n\nggtree(Monocots) %&gt;% ggtree::collapse(17) + geom_tiplab() + geom_point2(mapping = aes(subset=(node == 17)), size = 5, shape = 23, fill = \"steelblue\") + geom_tiplab(mapping = aes(subset = (node == 71), label = node), offset = 0.2) + coord_cartesian(xlim = c(0, 10), ylim = c(0, 12))\n\n\n\n\n\n\n\n\nIntroduza um triângulo em 1 nó colapsado com a função geom_polygon() do pacote ggplot2:\n\ntriangle=data.frame(x = c(5, 6, 6), y = c(8, 9, 7))\nggtree(Monocots) %&gt;% ggtree::collapse(17) + geom_tiplab() + geom_polygon(data = triangle, fill = \"darkgray\") + coord_cartesian(xlim = c(0, 10), ylim = c(0, 12))",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#anotando-dados-na-árvore-usando-r",
    "href": "all.html#anotando-dados-na-árvore-usando-r",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Anotando dados na árvore usando R",
    "text": "Anotando dados na árvore usando R\nDepois de plotar a árvore e alterar seu estilo, personalizando os nomes dos terminais e os ramos (linhas da árvore), vamos aprender a fazer anotações nos nós, ramos e nos terminais, tais como: os valores de suporte dos nós, comprimento dos ramos, plotar símbolos, gráficos de barras, pizzas, etc.\n\nPacote ape\n\nRamos\nAnotando texto nos ramos:\n\nVamos plotar etiquetas e textos nos ramos com a função edgelabels(). Com o argumento frame escolha se incluirá uma caixa de texto com formato circular (“circle”), com ângulos retos (“rect”, default), ou sem caixa de texto (“none”). Com o argumento bg pode alterar a cor de fundo da caixa de texto:\n\n\nplot(plants.tree)\nedgelabels(edge = 29, \"Monilófitas\", cex = 0.8, frame = \"rect\", bg = \"yellow\")\nedgelabels(edge = 21, \"11\", cex = 0.8, frame = \"circle\", bg = \"lightblue\")\nedgelabels(edge = 7, \"Angiospermas\", frame = \"none\", cex = 0.8, adj = c(0.5, -0.5))\n\n\n\n\n\n\n\n\n\nVamos utilizar a árvore na qual plotamos símbolos nos ramos para anotarmos texto sobre eles:\n\n\nplot(plants.tree)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 0)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = -0.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 0.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = -1)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 1)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = -1.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 1.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 2)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 2.5)\n\nedgelabels(edge = 6, 1, cex = 0.5, adj = c(7.3, -0.7), frame = \"none\")\nedgelabels(edge = 6, 2, cex = 0.5, adj = c(5.5, -0.7), frame = \"none\")\nedgelabels(edge = 6, 3, cex = 0.5, adj = c(3.9, -0.7), frame = \"none\")\nedgelabels(edge = 6, 4, cex = 0.5, adj = c(2.3, -0.7), frame = \"none\")\nedgelabels(edge = 6, 5, cex = 0.5, adj = c(0.5, -0.7), frame = \"none\")\nedgelabels(edge = 6, 6, cex = 0.5, adj = c(-1.2, -0.7), frame = \"none\")\nedgelabels(edge = 6, 7, cex = 0.5, adj = c(-2.8, -0.7), frame = \"none\")\nedgelabels(edge = 6, 8, cex = 0.5, adj = c(-4.5, -0.7), frame = \"none\")\nedgelabels(edge = 6, 9, cex = 0.5, adj = c(-6.3, -0.7), frame = \"none\")\n\n\n\n\n\n\n\n\n\nPodemos também escrever um texto inclinado usando o argumento srt:\n\n\nplot(plants.tree)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 0)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = -0.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 0.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = -1)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 1)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = -1.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 1.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 2)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 2.5)\nedgelabels(edge = 6, \"Caráter 1\", cex = 0.5, frame = \"none\", adj = c(0.4, -4.5),\n    srt = 55)\nedgelabels(edge = 6, \"Caráter 2\", cex = 0.5, frame = \"none\", adj = c(0.26, -3.5),\n    srt = 55)\nedgelabels(edge = 6, \"Caráter 3\", cex = 0.5, frame = \"none\", adj = c(0.14, -2.6),\n    srt = 55)\nedgelabels(edge = 6, \"Caráter 4\", cex = 0.5, frame = \"none\", adj = c(0, -1.5), srt = 55)\nedgelabels(edge = 6, \"Caráter 5\", cex = 0.5, frame = \"none\", adj = c(-0.15, -0.5),\n    srt = 55)\nedgelabels(edge = 6, \"Caráter 6\", cex = 0.5, frame = \"none\", adj = c(-0.29, 0.54),\n    srt = 55)\nedgelabels(edge = 6, \"Caráter 7\", cex = 0.5, frame = \"none\", adj = c(-0.4, 1.4),\n    srt = 55)\nedgelabels(edge = 6, \"Caráter 8\", cex = 0.5, frame = \"none\", adj = c(-0.53, 2.3),\n    srt = 55)\nedgelabels(edge = 6, \"Caráter 9\", cex = 0.5, frame = \"none\", adj = c(-0.65, 3.2),\n    srt = 55)\n\n\n\n\n\n\n\n\n\n\nTerminais\nAnotando texto nos terminais:\n\nVamos plotar textos nos terminais com a função tiplabels():\n\n\nplot(Monocots, label.offset=1)\ntiplabels()\n\n\n\n\n\n\n\nplot(Monocots, label.offset=1.5)\ntiplabels(\"1\", 1, frame = \"n\", adj=-0.2)\ntiplabels(\"A\", 2, frame = \"n\", adj=-0.2)\ntiplabels(\"teste\", 3, frame = \"n\", adj=-0.2)\n\n\n\n\n\n\n\n\n\nVamos plotar gráficos de barras e pizza nos terminais com os argumentos thermo e pie:\n\n\nplot(Monocots, label.offset = 1)\ntiplabels(pie = runif(11), cex = 1)\n\n\n\n\n\n\n\n\n\n\nNós\nAnotando texto nos nós:\n\nVamos plotar etiquetas e textos nos nós com a função nodelabels():\n\n\nplot(plants.tree)\nnodelabels()\n\n\n\n\n\n\n\nplot(plants.tree)\nnodelabels(\"Tracheophyta\", 28, frame = \"none\")\nnodelabels(\"Angiospermae\", 29, frame = \"n\")\n\n\n\n\n\n\n\n\n\nVamos plotar gráficos de barras e pizza nos nós com os argumentos thermo e pie. Vamos usar a função runif() para gerar números aleatórios de 0 a 1:\n\n\nplot(Monocots)\nnodelabels(thermo = runif(10), cex = 0.7)\n\n\n\n\n\n\n\nplot(Monocots)\nnodelabels(thermo = runif(10), cex = 0.7, horiz = TRUE)\n\n\n\n\n\n\n\nplot(Monocots)\nnodelabels(pie = runif(10), cex = 0.7)\n\n\n\n\n\n\n\n\n\nVamos plotar gráficos de barras e pizza nos nós com mais de duas proporções:\n\n\nprop_x &lt;- runif(22, 0, 0.33)\nprop_y &lt;- runif(22, 0, 0.33)\nprop_z &lt;- runif(22, 0, 0.33)\nprop_w &lt;- cbind(prop_x, prop_y, prop_z, 1 - prop_x - prop_y - prop_z)\nhead(prop_w)\n\n        prop_x      prop_y    prop_z          \n[1,] 0.2180898 0.211225608 0.3076319 0.2630527\n[2,] 0.1377760 0.138223793 0.1461143 0.5778859\n[3,] 0.2694679 0.046799897 0.1236775 0.5600547\n[4,] 0.1795874 0.299840194 0.2581990 0.2623734\n[5,] 0.1648238 0.003403854 0.2539796 0.5777927\n[6,] 0.2532573 0.140577720 0.3057229 0.3004421\n\nlayout(matrix(1:3, 1, 3))\nplot(Monocots, \"c\")\nnodelabels(thermo = prop_w, cex = 1.4)\nplot(Monocots, \"c\")\nnodelabels(thermo = prop_w, cex = 1.4, horiz = TRUE)\nplot(Monocots, \"c\")\nnodelabels(pie = prop_w, cex = 2)\n\n\n\n\n\n\n\n\n\n\n\nPacote phytools\nO pacote phytools não implementa funções específicas para escrever nos terminais e ramos, mas sim para os nós.\n\nNós\nDescubra os números dos nós com o argumento node.numbers:\n\nplotTree(Monocots, node.numbers = TRUE)\n\n\n\n\n\n\n\n\nPlote nomes nos nós:\n\nplotTree(plants.tree)\nlabels &lt;- c(\"Nome1\", \"Nome2\", \"Nome3\")\nlabelnodes(text = labels, node = c(25, 26, 27), shape = \"ellipse\", cex = 0.8,\n    interactive = FALSE)\n\n\n\n\n\n\n\n\nAdicionar nomes aos nós interativamente: (Retire os símbolos # da frente dos comandos)\n\n# plotTree(plants.tree) labelnodes(text = labels, shape = 'ellipse',\n# cex = 0.8, interactive = TRUE)\n\nAdicione nomes aos clados ao lado dos Terminais em árvore do tipo phylogram e cladogram: (Apenas os nós delimitam a chave)\n\nplotTree(plants.tree)\ncladelabels(text = \"Monilófita\", node = 41, offset = 11)\ncladelabels(text = \"Angiospermas\", node = 30, offset = 11)\n\n\n\n\n\n\n\n\nAdicione nomes aos clados ao lado dos terminais em árvore do tipo fan. Com o argumento ylim estabeleça os limites da plotagem:\n\nplotTree(plants.tree, type = \"fan\", fsize = 0.7, ylim = c(-2, 2), offset = 1)\narc.cladelabels(text = \"Gimnospermas\", node = 38, ln.offset = 1.6, lab.offset = 1.8,\n    orientation = \"curved\")\narc.cladelabels(text = \"Angiospermas\", node = 30, ln.offset = 1.8, lab.offset = 2,\n    orientation = \"curved\")\n\n\n\n\n\n\n\n\nAdicionando uma barra de erro nos nós com o método plotTree.errorbars():",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "all.html#plotando-matrizes-data.frames-e-árvore-ao-lado-da-árvore-usando-r",
    "href": "all.html#plotando-matrizes-data.frames-e-árvore-ao-lado-da-árvore-usando-r",
    "title": "Alinhamento múltiplo e manual de sequências",
    "section": "Plotando matrizes, data.frames e árvore ao lado da árvore usando R",
    "text": "Plotando matrizes, data.frames e árvore ao lado da árvore usando R\n…\n\nPacote ape\nO pacote ape possui três funções para plotar matrizes, dataframes, e outra árvore ao lado de uma árvore (tanglegram): phydataplot(), ring() e cophyloplot().\n\nMatriz e data.frame\n\nDados contínuos\nPlote diferentes layouts ao lado da árvore:\n\ndata &lt;- c(2,3,1,2,7,5,4,10,13,12,11)\nnames(data) &lt;- Monocots$tip.label\nplot(Monocots, x.lim = 60)\nphydataplot(data, Monocots, offset = 14)\n\n\n\n\n\n\n\nplot(Monocots, x.lim = 60)\nphydataplot(data, Monocots, offset = 14, col = \"yellow\")\n\n\n\n\n\n\n\nplot(Monocots, x.lim = 60)\nphydataplot(data, Monocots, offset = 14, \"d\")\n\n\n\n\n\n\n\nplot(Monocots, x.lim = 60)\nphydataplot(data, Monocots, offset = 14, \"s\", lwd = 3)\n\n\n\n\n\n\n\n\n\ntx &lt;- rcoal(m &lt;- 20)\nX &lt;- runif(m, 0, 0.5); Y &lt;- runif(m, 0, 0.5)\nX &lt;- cbind(X, Y, 1 - X - Y)\nX\n\n                X           Y           \n [1,] 0.447427611 0.394670526 0.15790186\n [2,] 0.177303199 0.181315499 0.64138130\n [3,] 0.451538792 0.460047258 0.08841395\n [4,] 0.026462488 0.291000439 0.68253707\n [5,] 0.254227641 0.042983822 0.70278854\n [6,] 0.182282617 0.456427275 0.36129011\n [7,] 0.457063184 0.178647978 0.36428884\n [8,] 0.361325434 0.068432832 0.57024173\n [9,] 0.281824557 0.412025286 0.30615016\n[10,] 0.295609034 0.263235388 0.44115558\n[11,] 0.434559145 0.198112558 0.36732830\n[12,] 0.001841225 0.400714067 0.59744471\n[13,] 0.497357500 0.257174738 0.24546776\n[14,] 0.095966873 0.249165863 0.65486726\n[15,] 0.173672952 0.151147687 0.67517936\n[16,] 0.225444872 0.257146075 0.51740905\n[17,] 0.056682864 0.261417988 0.68189915\n[18,] 0.162531866 0.006995703 0.83047243\n[19,] 0.236796147 0.444786076 0.31841778\n[20,] 0.265963067 0.086660565 0.64737637\n\nrownames(X) &lt;- tx$tip.label\nplot(tx, x.lim = 6)\nco &lt;- rgb(diag(3))\nphydataplot(X, tx, col = co)\n\n\n\n\n\n\n\n\n\npar(mar=c(3, 3, 3, 3))\nZ &lt;- matrix(rnorm(m * 5), m)\nrownames(Z) &lt;- rownames(X)\nplot(tx, x.lim = 5)\nphydataplot(Z, tx, \"bo\", scaling = .5, offset = 0.5, boxfill = c(\"gold\", \"skyblue\"))\n\n\n\n\n\n\n\n\n\n\nDados discretos\nPlote uma matriz de diferentes estados para carda caráter com cores diferentes:\n\nc1 &lt;- rep(c(\"estado 1\", \"estado 2\", \"estado 3\"), 10/2)\nnames(c1) &lt;- Monocots$tip.label\nc2 &lt;- rep(c(\"estado 4\", \"estado 5\", \"estado 6\"), 10/2)\nnames(c2) &lt;- Monocots$tip.label\nc3 &lt;- rep(c(\"estado 2\", \"estado 3\", \"estado 4\"), 10/2)\nnames(c3) &lt;- Monocots$tip.label\nmatriz_c &lt;- cbind(c1, c2, c3)\nplot(Monocots, x.lim = 60)\nphydataplot(matriz_c, Monocots, \"m\", width = 2, offset = 14, legend = \"side\")\n\n\n\n\n\n\n\n\n\n\n\nAnéis em árvores circulares\nA função ring() plota dados contínuos e discretos em árvores do tipo “fan”.\n\nDados contínuos\nPlote uma barra de proporções igual a 1:\n\nplot(tx, \"f\", show.tip.label = FALSE, open.angle = 180, x.lim = c(-1, 2), y.lim = c(-2,\n    3.1))\nring(X, tx, col = co, offset = 0.05)\n\n\n\n\n\n\n\n\nPlote mais de um anel de carateres:\n\nts &lt;- rcoal(100)\nX1 &lt;- rTraitCont(ts)\nX2 &lt;- rTraitCont(ts)\nX3 &lt;- rTraitCont(ts)\nco &lt;- c(\"blue\", \"red\")\nX1 &lt;- X1 + abs(min(X1))\nX2 &lt;- X2 + abs(min(X2))\nX3 &lt;- X3 + abs(min(X3))\nop &lt;- par(mar = rep(0, 4))\npar(xpd = TRUE, mar = op$mar)\nplot(ts, \"f\", show.tip.label = FALSE, x.lim = c(-3, 3), y.lim = c(-3, 3),\n    open.angle = 30)\nphydataplot(X1, ts, \"s\", col = co, offset = 0.1, lwd = 5)\nring(X2, ts, \"ring\", col = co, offset = max(X) + 0.3, lwd = 4)\nring(X3, ts, \"ring\", col = co, offset = max(X) + 0.7, lwd = 4)\n\n\n\n\n\n\n\n\n\n\nDados discretos\nPlote duas camadas de anéis:\n\nco &lt;- c(\"lightblue\", \"yellow\")\nco2 &lt;- c(\"lightgreen\", \"lightpink\")\nop &lt;- par(mar = rep(0, 4))\npar(xpd = TRUE, mar = op$mar)\nplot(ts, \"r\", cex = 0.5)\nring(0.1, ts, \"r\", col = sample(co, size = 100, rep = TRUE), offset = 0.3)\nring(0.1, ts, \"r\", col = sample(co2, size = 100, rep = TRUE), offset = 0.5)\n\n\n\n\n\n\n\n\n\n\n\nTanglegram\n\n# Gerar 2 árvores aleatórias com 10 terminais com a função rtree(). As árvores\n# não precisam conter exatamente os mesmos terminais, mas as linhas serão\n# formadas apenas nos terminais com nomes iguais.\ntree1 &lt;- rtree(10)\ntree2 &lt;- rtree(10)\n# Criação de uma matriz de associação:\nassociation &lt;- cbind(tree2$tip.label, tree2$tip.label)\ncophyloplot(tree1, tree2, assoc = association, length.line = 4, space = 28, gap = 3)\n\n\n\n\n\n\n\n# Rotacionar árvore interativamente com argumento rotate: (Retire o # da frente\n# do comando) cophyloplot(tree1, tree2, assoc = association, length.line = 4,\n# space = 28, gap = 3, rotate = TRUE)\n\n\n\n\nPacote phytools\nO pacote phytools possui a função dotTree() e mais três métodos específicos da função plotTree() para plotar círculos, barras, matrizes e boxplots: plotTree.barplot(), plotTree.datamatrix() e plotTree.boxplot():\n\nCírculos\nPlote esferas com tamanho diferenciado de acordo com dados contínuos com a função dotTree():\n\n# Vamos obter a árvore e dados do Blog oficial o pacote Phytools:\ntree &lt;- ape::read.tree(\"http://www.phytools.org/Cordoba2017/data/tree.tre\")\nx &lt;- as.matrix(read.csv(\"http://www.phytools.org/Cordoba2017/data/x.csv\",\n    row.names = 1))[, 1]\n# Agora plote:\ndotTree(tree, x, length = 10, ftype = \"i\")\n\n\n\n\n\n\n\n\nPlote círculos coloridos para representar caracteres discretos:\n\neel.tree &lt;- read.tree(\"http://www.phytools.org/Cordoba2017/data/elopomorph.tre\")\neel.data &lt;- read.csv(\"http://www.phytools.org/Cordoba2017/data/elopomorph.csv\",\n    row.names = 1)\nfmode &lt;- as.factor(setNames(eel.data[, 1], rownames(eel.data)))\ndotTree(eel.tree, fmode, colors = setNames(c(\"blue\", \"red\"), c(\"suction\",\n    \"bite\")), ftype = \"i\", fsize = 0.7)\n\n\n\n\n\n\n\n\n\n\nBarras\nPlote barras com tamanho diferenciado de acordo com dados contínuos com o método plotTree.barplot(). Utilizaremos os mesmos dados obtidos a cima:\n\nplotTree.barplot(tree, x)\n\n\n\n\n\n\n\n\nExperimente colorir as barras do exemplo a cima:\n\nplotTree.barplot(tree, x, args.barplot = list(col = sapply(x, function(x) if (x &gt;=\n    0) \"blue\" else \"red\"), xlim = c(-4, 4)))\n\n\n\n\n\n\n\n\nPlote mais de um caráter: (os objetos tx e X foram usados no exercício do pacote ape)\n\nplotTree.barplot(tx, X)\n\n\n\n\n\n\n\n\nPlote mais de um caráter em barras separadas:\n\nplotTree.barplot(tx, X, args.barplot = list(beside = TRUE, xlim = c(0,\n    1), legend.text = TRUE, space = c(0, 1.2), args.legend = list(x = 1,\n    y = 24)))\n\n\n\n\n\n\n\n\nTeste também uma outra opção implementada no phytools, a o método plotTree.wBars(): [http://blog.phytools.org/2015/04/plottreewbars-with-tip-labels.html]\n\ntip.label &lt;- replicate(200, paste(sample(LETTERS, 1), \"._\", paste(sample(letters,\n    round(runif(n = 1, min = 4, max = 8))), collapse = \"\"), sep = \"\"))\ntree &lt;- pbtree(n = 200, tip.label = tip.label, scale = 1)\nx &lt;- abs(fastBM(tree))\nplotTree.wBars(tree, x, fsize = 0.4, scale = 0.1, tip.labels = TRUE, type = \"fan\",\n    lwd = 1, offset = 1)\n\n\n\n\n\n\n\n\n\n\nMatrizes\nPlote uma matriz com dados discretos com o método plotTree.datamatrix():\n\nlibrary(phytools)\ntree &lt;- rtree(n = 40)\nQ1 &lt;- matrix(c(-1, 1, 1, -1), 2, 2, dimnames = list(0:1, 0:1))\nx1 &lt;- sim.Mk(tree, Q1)\nQ2 &lt;- matrix(c(-1, 1, 0, 1, -2, 1, 0, 1, -1), 3, 3, dimnames = list(letters[1:3],\n    letters[1:3]))\nx2 &lt;- sim.Mk(tree, Q2)\nQ3 &lt;- matrix(c(-0.5, 0.5, 0.5, -0.5), 2, 2, dimnames = list(c(\"rough\",\n    \"smooth\"), c(\"rough\", \"smooth\")))\nx3 &lt;- sim.Mk(tree, Q3)\nQ4 &lt;- matrix(c(-3, 1, 1, 1, 1, -3, 1, 1, 1, 1, -3, 1, 1, 1, 1, -3), 4,\n    4, dimnames = list(LETTERS[1:4], LETTERS[1:4]))\nx4 &lt;- sim.Mk(tree, Q4)\nX &lt;- data.frame(x1, x2, x3, x4)\ncolnames(X) &lt;- c(\"Trait 1\", \"Trait 2\", \"Trait 3\", \"Trait 4\")\nobject &lt;- plotTree.datamatrix(tree, X, sep = 0, srt = 90, yexp = 1.1, xexp = 1.1,\n    fsize = 0.8, space = 0.2)\n\nLoading required package: RColorBrewer\n\n\n\n\n\n\n\n\n\nFaça algumas alterações no estilo da matriz:\n\nobject &lt;- plotTree.datamatrix(tree, X, sep = 0, srt = 70, yexp = 1.05,\n    fsize = 0.8)\nx &lt;- object$end.x + diff(par()$usr[1:2]) * 0.01\ny &lt;- Ntip(tree)\nfor (i in 1:ncol(X)) {\n    text(x, y, colnames(X)[i], pos = 4, cex = 0.9, offset = 0)\n    add.simmap.legend(colors = object$colors[[i]], shape = \"square\", prompt = FALSE,\n        x = x, y = y - 2 * strheight(\"W\") * 0.9, fsize = 0.9)\n    y &lt;- y - 1.5 * 0.9 * strheight(\"W\") * (length(object$colors[[i]]) -\n        1) - 6\n}\n\n\n\n\n\n\n\n\n\n\nBoxplots\n\ntree &lt;- pbtree(n = 26, tip.label = LETTERS[26:1])\n# Simule species means\nx &lt;- fastBM(tree)\n# Simule diferentes amostras de cada terminal (5 por terminal):\nxe &lt;- sampleFrom(x, setNames(rep(0.5, Ntip(tree)), tree$tip.label), setNames(rep(5,\n    Ntip(tree)), tree$tip.label))\nplotTree.boxplot(tree, xe)\n\n\n\n\n\n\n\n\n\n\nTanglegram\nGere duas ávores aleatórias com os mesmos terminais:\n\nt1 &lt;- rtree(n = 20, tip.label = letters[1:20])\nt2 &lt;- rtree(n = 20, tip.label = letters[1:20])\n\nCrie o objeto de classe cophylo com a função de mesmo nome:\n\nobj &lt;- cophylo(t1, t2)\n\nRotating nodes to optimize matching...\nDone.\n\n\nPlote o objeto criado com a função plot.cophylo:\n\nplot.cophylo(obj)\n\n\n\n\n\n\n\n\nAltere parâmetros estéticos com argumentos da função plot.cophylo. Altere a espessura dos ramos da árvore com o argumento lwd. Altere a estética da linha que une os terminais com o argumento link.type = “curved”:\n\nplot.cophylo(obj, lwd = 2, link.type = \"curved\")\n\n\n\n\n\n\n\n\nAltere o tipo de linha com o argumento link.lty:\n\nplot(obj, link.lty = 0)\n\n\n\n\n\n\n\nplot(obj, link.lty = 1)\n\n\n\n\n\n\n\nplot(obj, link.lty = 2)\n\n\n\n\n\n\n\nplot(obj, link.lty = 3)\n\n\n\n\n\n\n\nplot(obj, link.lty = 4)\n\n\n\n\n\n\n\n\nAltere a cor da linha que une os terminais das árvores com o argumento link.col.\n\nplot(obj, link.col = \"red\")\n\n\n\n\n\n\n\n\nAplique uma transparência na cor com a função make.transparent:\n\nplot(obj, link.lwd = 3, link.lty = 1, link.col = make.transparent(\"blue\", 0.25))\n\n\n\n\n\n\n\n\nRetire os pontos do final dos ramos com o argumento pts = FALSE:\n\nplot(obj, pts = FALSE)\n\n\n\n\n\n\n\n\nAltere os pontos do final dos ramos com a método tiplabels.cophylo:\n\nplot(obj)\ntiplabels.cophylo(pie = to.matrix(rep(1, Ntip(obj$trees[[1]])), \"1\"), cex = 0.3,\n    piecol = \"red\")\ntiplabels.cophylo(pie = to.matrix(rep(1, Ntip(obj$trees[[2]])), \"1\"), cex = 0.3,\n    piecol = \"grey\", which = \"right\")\n\n\n\n\n\n\n\n\nRemova os nomes ou altere a fonte dos terminais com o argumento ftype:\n\nplot(obj, ftype = \"off\")\n\n\n\n\n\n\n\nplot(obj, ftype = \"b\")\n\n\n\n\n\n\n\n\nAltere o tamanho da fonte dos terminais com o argumento fsize:\n\nplot(obj, fsize = 1.3)\n\n\n\n\n\n\n\n\nAltere a linha que une a árvore aos terminais. Altere o tipo de linha com o argumento tip.lty (0 = sem linha). Altere a distância entre a árvore e os terminais com o argumento tip.len. Altere a distância entre os terminais de ambas as árvores com o argumento part:\n\nplot(obj, tip.lty = 0, tip.len = 0.05, part = 0.35)\n\n\n\n\n\n\n\n\nAgora veja esse estilo:\n\nplot(obj, link.type = \"curved\", link.lwd = 3, link.lty = 1, lwd = 2,\n    link.col = make.transparent(\"blue\", 0.25), fsize = 1.2)\n\n\n\n\n\n\n\n\n\n\nPhylo.to.map\nConheça a função phylo.to.map() para plotar um mapa com coordenadas geográficas ao lado da árvore. No código abaixo, estamos gerando dados aleatórios:\n\ntree &lt;- pbtree(n = 26, scale = 100)\ntree$tip.label &lt;- LETTERS[26:1]\nlat &lt;- fastBM(tree, sig2 = 10, bounds = c(-90, 90))\nlong &lt;- fastBM(tree, sig2 = 80, bounds = c(-180, 180))\nxx &lt;- phylo.to.map(tree, cbind(lat, long), plot = FALSE)\n\nobjective: 292\n\n\nobjective: 122\n\n\nobjective: 120\nobjective: 120\nobjective: 120\nobjective: 120\n\n\nobjective: 108\nobjective: 108\nobjective: 108\nobjective: 108\nobjective: 108\n\n\nobjective: 98\nobjective: 98\nobjective: 98\nobjective: 98\nobjective: 98\nobjective: 98\nobjective: 98\n\n\nobjective: 96\n\n\nobjective: 92\nobjective: 92\nobjective: 92\nobjective: 92\nobjective: 92\nobjective: 92\n\nplot(xx, type = \"phylogram\", asp = 1.3, mar = c(0.1, 0.5, 3.1, 0.1))\n\n\n\n\n\n\n\n\nVeja um exemplo pronto com dados reais (Fig. @ref{fig:Phylo.to.map}):\n\n\nEscala estratigráfica\nPlote a escala estratigráfica, com dados gerados aleatoriamente, com a função geo.legend() [http://blog.phytools.org/2017/05/new-features-in-geolegend-for-adding.html]:\n\ntree &lt;- pbtree(b = 0.03, d = 0.01, n = 200)\nh &lt;- max(nodeHeights(tree))\n# Primeiro ajuste a legenda sem plotar a árvore:\nplotTree(tree, plot = FALSE)\nobj &lt;- geo.legend(alpha = 0.3, cex = 1.2, plot = T)\n\n\n\n\n\n\n\n# plote a árvore e a legenda estratigráfica:\nplotTree(tree, ftype = \"off\", ylim = c(-0.2*Ntip(tree), Ntip(tree)), lwd = 1)\ngeo.legend(leg = obj$leg, colors = obj$colors, cex = 1.2)",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Alinhamento múltiplo e manual de sequências</span>"
    ]
  },
  {
    "objectID": "tecnicas-moleculares.html",
    "href": "tecnicas-moleculares.html",
    "title": "Técnicas moleculares",
    "section": "",
    "text": "Extração do DNA",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Técnicas moleculares</span>"
    ]
  },
  {
    "objectID": "tecnicas-moleculares.html#extração-do-dna",
    "href": "tecnicas-moleculares.html#extração-do-dna",
    "title": "Técnicas moleculares",
    "section": "",
    "text": "O protocolo de extração de DNA é a primeira etapa do laboratório de análise molecular.\nO “protocolo CTAB” solução tampão CTAB (Doyle e Doyle 1987).\n\nMaceração\n\nColocar 20–30 mg de material desidratado em sílica em microtubo (eppendorf) de 2 ml e 8–10 esferas de aço (2 mm)\n\n\n\nMacerar no Mini-Beadbeater (BioSpec) \n\n\nAdição do tampão CTAB\n\n\n\nCentrifugar\n\n\n\nLavar o pellet\n\n\n\n\n\n\n\n\nEtapa de pré-lavagem com sorbitol para materiais herborizados (Inglis et al. 2018).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Técnicas moleculares</span>"
    ]
  },
  {
    "objectID": "tecnicas-moleculares.html#amplificação",
    "href": "tecnicas-moleculares.html#amplificação",
    "title": "Técnicas moleculares",
    "section": "Amplificação",
    "text": "Amplificação\n\nA Reação em cadeia da polimerase (Polymerase Chain Reaction - PCR) é um procedimento para clonagem molecular.\nEnzimas de restrição (tesouras moleculares)\n\nReconhecem e clivam diferentes sítios de restrição.\n\nPrimers (DNAs iniciadores)\nEnzima DNA polimerase\n\nFaz a replicação do DNA.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Técnicas moleculares</span>"
    ]
  },
  {
    "objectID": "tecnicas-moleculares.html#eletroforese",
    "href": "tecnicas-moleculares.html#eletroforese",
    "title": "Técnicas moleculares",
    "section": "Eletroforese",
    "text": "Eletroforese\n\nTécnica usada para separar fragmentos de DNA de acordo com seu tamanho.\nAs amostras são colocadas nos poços localizados em uma das extremidades de um gel de agarose, e uma corrente elétrica é aplicada para que as amostras avancem pelo gel.\nQuando um gel é pigmentado com um corante que se liga ao DNA, os fragmentos de DNA podem ser vistos como bandas. Cada banda representa um grupo de fragmentos de DNA de mesmo tamanho.\n\n\n\n\nPara a visualização se utiliza a luz UV de um transiluminador.\n\n A concentração da amostra é crucial para o sucesso da reação de sequencimento. Usar muito pouco DNA é um erro que leva a nenhum sinal ou a sinais fracos, mas usar muito é um erro também!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Técnicas moleculares</span>"
    ]
  },
  {
    "objectID": "tecnicas-moleculares.html#sequenciamento",
    "href": "tecnicas-moleculares.html#sequenciamento",
    "title": "Técnicas moleculares",
    "section": "Sequenciamento",
    "text": "Sequenciamento\n\nHistória do sequenciamento didesoxi Sanger\nO sequenciador ABI utiliza o método de sequenciamento tradicional, proposto por Frederick e Sanger na década de 70, para gerar sequências entre 300 e 850pb. Na reação de sequenciamento são utilizados, além dos nucleotídeos comuns, nucleotídeos modificados e marcados com fluorescência, chamados dideoxirribonucleotídeos. Cada nucleotídeo (A, C, G, T) é marcado com um fluoróforo distinto. Durante a reação de extensão do fragmento de DNA, quando um nucleotídeo modificado é incorporado ao fragmento, o que ocorre de forma aleatória, a reação é interrompida. Os fragmentos de DNA gerados serão, portanto, de tamanhos diversos. Depois de separados por eletroforese capilar, uma câmera CCD (detector) acoplada ao equipamento irá identificar a fluorescência emitida pelo nucleotídeo marcado e assim caracterizá-lo (https://www.einstein.br/pesquisa/pesquisa-experimental/plataformas/plataforma-sequenciamento).\n\n\nOs princípios de replicação do DNA foram usados por Sanger et al. no desenvolvimento do processo agora conhecido como sequenciamento didesoxi Sanger.\nEsse processo aproveita a capacidade da DNA polimerase de incorporar 2’,3’-didesoxinucleotídeos – análogos de bases nucleotídicas que não possuem o grupo 3’-hidroxila essencial na formação da ligação fosfodiéster (DNA Sequencing by Capillary Electrophoresis 3ed).\nO sequenciamento de didesoxi Sanger requer um molde de DNA, um primer de sequenciamento, DNA polimerase, desoxinucleotídeos (dNTPs), didesoxinucleotídeos (ddNTPs) e tampão de reação.\nQuatro reações separadas são configuradas, cada uma contendo nucleotídeos marcados radioativamente e ddA, ddC, ddG ou ddT.\nAs etapas de anelamento, rotulagem e terminação são realizadas em blocos térmicos separados.\n\nA síntese de DNA é realizada a 37°C, a temperatura na qual a DNA polimerase tem a atividade enzimática ideal.\nA DNA polimerase adiciona um desoxinucleotídeo ou o correspondente 2’,3’-didesoxinucleotídeo em cada etapa da extensão da cadeia.\nA adição de um desoxinucleotídeo ou um didesoxinucleotídeo depende da concentração relativa de ambas as moléculas. Quando um desoxinucleotídeo (A, C, G ou T) é adicionado à extremidade 3’, a extensão da cadeia pode continuar. No entanto, quando um didesoxinucleotídeo (ddA, ddC, ddG ou ddT) é adicionado à extremidade 3’, a extensão da cadeia termina. O sequenciamento dideoxy Sanger resulta na formação de produtos de extensão de vários comprimentos terminados com dideoxynucleotídeos no final de 3’.\n\n\nO sequenciador ABI (Applied Biosystems) é um instrumento baseado em laser que utiliza marcadores fluorescentes para analisar os produtos de uma reação de sequenciamento à medida que migram através de um gel. Depois que os dados são coletados a partir de uma execução de sequenciamento, o programa Analysis da Applied Biosystems identifica e rastreia os rastros (traces) de amostra do gel e, subsequentemente, normaliza e integra os dados brutos (raw data) em um cromatograma da sequência final.\nBases ambíguas tendem a ocorrer perto do final da sequência e podem ser editados ou excluídos pelo usuário antes de exportar os dados para outras comparações ou alinhamentos (Hagemann e Kwan 1999).\n\n\n\n\nDoyle, J. J., e J. L. Doyle. 1987. «A rapid DNA isolation procedure for small quantities of fresh leaf tissue». Phytochemical Bulletin 19: 11–15.\n\n\nHagemann, Tracy L., e Sau-Ping Kwan. 1999. «ABI Sequencing Analysis: Manipulation of Sequence Data from the ABIDNASequencer». Molecular Biotechnology 13 (2): 137–52. https://doi.org/10.1385/mb:13:2:137.\n\n\nInglis, Peter W, Marilia de Castro R Pappas, Lucileide V Resende, e Dario Grattapaglia. 2018. «Fast and inexpensive protocols for consistent extraction of high quality DNAand RNAfrom challenging plant and fungal samples for high-throughput SNPgenotyping and sequencing applications». PLoS One 13 (10): e0206085.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Técnicas moleculares</span>"
    ]
  },
  {
    "objectID": "filoinformatica.html",
    "href": "filoinformatica.html",
    "title": "Filoinformática",
    "section": "",
    "text": "Conceito",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Filoinformática</span>"
    ]
  },
  {
    "objectID": "filoinformatica.html#conceito",
    "href": "filoinformatica.html#conceito",
    "title": "Filoinformática",
    "section": "",
    "text": "Falta uma definição amplamente aceita, mas qualquer conceito deve considerar as funções da informática de: coleta, classificação, tratamento, processamento, armazenamento, recuperação e integração, bem como a de apresentação e representação de dados.\n\n\nCampo que abrange todas as etapas, tarefas e usos de ferramentas computacionais envolvidas na produção do conhecimento filogenético, desde a obtenção ao tratamento, às análises e metanálises, armazenamento, recuperação, integração e representação de dados.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Filoinformática</span>"
    ]
  },
  {
    "objectID": "filoinformatica.html#fontes-de-dados",
    "href": "filoinformatica.html#fontes-de-dados",
    "title": "Filoinformática",
    "section": "Fontes de dados",
    "text": "Fontes de dados\n\nGrande parte do desafio está no gerenciamento e interoperabilidade de bases de dados.\nDados relacionado a estudos filogenéticos incluem:\n\nnomenclatura;\ntaxonomias;\nespécimes(vouchers);\ndistribuição espacial (geográfica);\ndados abióticos;\nmatrizes de estados de caracteres;\ndescrições dos estados de caracteres;\nsequências de ácidos nucleicos;\nalinhamentos de sequências;\nárvores filogenéticas e metadados;\ngenômica e proteômica;\ndados da biodiversidade;\nautores e referências bibliográficas.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Filoinformática</span>"
    ]
  },
  {
    "objectID": "filoinformatica.html#perspectivas",
    "href": "filoinformatica.html#perspectivas",
    "title": "Filoinformática",
    "section": "Perspectivas",
    "text": "Perspectivas\n\nO poder preditivo da filoinformática instiga os biólogos à persuasiva busca pela descoberta de todos os ramos da Árvore da Vida, o mais rapidamente possível. A geração de uma base de dados única que interconecte informação filogenética às outras bases de dados sobre biodiversidade é a mais importante contribuição da Sistemática para a humanidade (Cracraft 2002).\nFiloepidemiologia / Filodinâmica\n\n\nForster, P., 2020. Phylogenetic network analysis of SARS-CoV-2 genomes\n\nO conhecimento filogenético é cada vez mais usado como uma ponte entre a genômica funcional, a evolução e o desenvolvimento — desvendar como o genótipo se torna fenótipo exige que conheçamos a filogenia quase tão bem quanto conhecemos a genômica (Piel, Sanderson, e Donoghue 2003).\nMuitas das implicações do desenvolvimento dessa tecnologia ainda não foram sequer pensadas.\n\n\n\n\n\nCracraft, J. 2002. «The Seven Great Questions of Systematic Biology: An Essential Foundation for Conservation and the Sustainable Use of Biodiversity». Annals of the Missouri Botanical Garden 89: 127–44. https://www.biodiversitylibrary.org/part/16378.\n\n\nPiel, W. H., M. J. Sanderson, e M. J. Donoghue. 2003. «The small-world dynamics of tree networks and data mining in phyloinformatics». Bioinformatics 19 (9): 1162–68. https://doi.org/10.1093/bioinformatics/btg131.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Filoinformática</span>"
    ]
  },
  {
    "objectID": "visao-geral.html",
    "href": "visao-geral.html",
    "title": "Visão geral e roteiro do curso",
    "section": "",
    "text": "Em nossas práticas, utilizaremos dados moleculares na condução das análises filogenéticas. Quanto aos métodos de inferência filogenética, rodaremos análises de máxima verossimilhança e bayesiana. Não rodaremos análises de parsimônia, uma vez que o enfoque do curso será nos dados moleculares. Atualmente, é consensual que ambas as análises, de máxima verossimilhança e bayesiana, são mais apropriadas do que a máxima parsimônia quando se tratam de dados moleculares (genotípicos). Não obstante, a análise de parsimônia continua a ser uma abordagem importante quando os dados são de natureza fenotípica (por exemplo, morfológicos).\nIniciaremos nossas atividades com a etapa de montagem de sequências, onde aprenderemos a montar uma sequência consenso a partir dos primers sequenciados.\nEm seguida, aprenderemos a baixar sequências do Genbank e a editar os principais tipos de arquivos que armazenam dados filogenéticos. Para isso, faremos uso das expressões regulares através de um editor de texto plano.\nEntão, realizaremos o alinhamento múltiplo e manual das sequências, onde construiremos a matriz com os dados moleculares.\nAprenderemos o básico sobre o terminal (ou console ou shell) do Windows - MS-DOS, conhecimentos que serão essenciais utilizar aplicativos com interface de linha de comando (CLI, em inglês) e para procederemos as análises filogenéticas.\nAs análises filogenéticas serão rodadas com dados moleculares. Utilizaremos os programas IQ-TREE para máxima verossimilhança, e MrBayes e Beast2 para bayesiana.\nEntão, aprenderemos o básico sobre o r fa(\"r-project\", fill = \"steelblue\") para apresentarmos os principais pacotes desenvolvidos para análises filogenéticas e afins. Uma grande atenção será dada à edição de árvores filogenéticas através de três pacotes (ape, phytools, ggtree).\nFinalmente, uma introdução ao RMarkdown para redação da documentação e apresentação dos códigos encerra o curso de introdução à filoinformática.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Visão geral e roteiro do curso</span>"
    ]
  },
  {
    "objectID": "montagem.html",
    "href": "montagem.html",
    "title": "Montagem de sequências",
    "section": "",
    "text": "Cromatogramas\nA primeira etapa computacional de uma análise filogenética é a montagem das sequências (sequence assembly) de cada um dos terminais a partir dos cromatogramas de cada primer sequenciado.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Montagem de sequências</span>"
    ]
  },
  {
    "objectID": "montagem.html#cromatogramas",
    "href": "montagem.html#cromatogramas",
    "title": "Montagem de sequências",
    "section": "",
    "text": "Conceito\n\nRastro (trace) do sinal dos nucleotídeos marcados por corante de acordo com a intensidade, indicada por quatro cores correspondentes às quatro bases nitrogenadas.\n\n\n\nFinalidade\n\nVerificar a qualidade do sinal\nDetecção dos picos\n\nA baixa qualidade do sinal é denominado de ruído (noise). O ruído é caracterizado por picos pouco acentuados, com altura mais baixa e mais largos.\n\n\nQualidade do sinal\n\nAlta\n\nSem ambiguidade\nPicos adequadamente distantes com espaços regulares\nSem ruído\n\n\nMédia\n\nAlgumas ambiguidades\nPicos adequadamente distantes com espaços regulares\nAlguns trechos homopoliméricos não estão bem resolvidos\n\n\nBaixa\n\nAlgumas ambiguidades\n\n\n\n\nFonte: DNA Baser - What are chromatograms?\n\n\nArquivo .ab1\nO arquivo .ab1 contém o eletroferograma da sequência de DNA, bem como dados brutos e outras informações.\nO arquivo .ab1 são gerados pelos sequenciadores da Applied Biosystems. Outros sequenciadores utilizam arquivos nos formatos .scf (Standard Chromatogram Format) e .ztr.\nDois programas foram desenvolvidos especialmente para visualizar os cromatogramas:\n\nChromas\nFinchTV\n\n… mas diversos programas podem realizar a tarefa.\n\n\nSoftware FitchTV\n\n\n\n\n\nO FinchTV 1.4 é um programa open-source para visualização da qualidade e intensidade dos sinais obtidos. Com ele, é possível analisar os dados brutos do cromatograma (raw data).\n\n\n\n\n\nManual do sequenciamento Sanger\nDiversos fatores podem resultar em baixa resolução do sinal. Observe o capítulo 8 (Troubleshooting) do guia da Applied Biosystems para entender alguns dos principais problemas no sequenciamento:\nDNA Sequencing by Capillary Electrophoresis 3ed.\n\n\nWarning: package 'xaringanExtra' was built under R version 4.2.3\n\n\n\n\n\n\n\n\n\n\nInterpretação do cromatograma\nO processo automatizado de detecção de contigs através do algoritmo base calling de um software é sujeito à erros. E não é raro ocorrerem. Isso deve-se à baixa qualidade do sinal em certas regiões do cromatograma. A qualidade do sinal varia em função de inúmeros fatores e, geralmente, está relacionada à etapa das reações de sequenciamento. Compostos secundários, concentração inadequada de DNA amplificado, presença de contaminantes ou impurezas, ou qualquer outra razão misteriosa, pode atrapalhar as reações de sequenciamento, levando a uma baixa qualidade do sinal. Portanto, o filogeneticista precisa revisar visualmente e manualmente toda a sequência montada automaticamente por um software. Ademais, também é da própria natureza da tecnologia de sequenciamento Sanger, que a qualidade e resolução do sinal começa baixa, mas vai gradativamente melhorando a partir do início da reação, porém começa a decair após um determinado ponto. Consequentemente, a depender da qualidade do cromatograma, a duração dessa tarefa de montagem das sequências pode variar.\nAdemais, após o alinhamento múltiplo das sequências, é preciso reconferir os cromatogramas das sequências montadas. Por isso, é fundamental salvá-las no software utilizado. Cada software salvará como um arquivo específico, que não pode ser lido por outros programas. A tarefa de reconferir as montagens após o alinhamento múltiplo é trabalhosa, mas essencial para a correta codificação das homologias moleculares.\nComo decorrência do problema eventual de baixa resolução no cromatograma em algumas posições, um código de ambiguidade de nucleotídeos foi estabelecido pela IUPAC durante o Comitê de Nomenclatura da União Internacional de Bioquímica (NC-IUB), em 1984 (Cornish-Bowden 1985).\n\n\n\nPrática\n\nPara essa atividade será preciso baixar o FitchTV.\nVamos abrir alguns arquivos do cromatograma da região trnD-T de um organismo desconhecido (species_1):\n\nspecies_1_trnD-T(T).ab1\nspecies_1_trnD-T(E).ab1\nspecies_1_trnD-T(Y).ab1\nspecies_1_trnD-T(D).ab1\n\nObserve o raw data dos cromatogramas:\n\nClique na aba View -&gt; Raw Data;\nNa janela que se abre, arraste o Horizontal Scale totalmente pra esquerda.\n\n\n\nHá arquivos .ab1 nesse site: https://www.vanderbilt.edu/wolbachiaproject/lab-5-dna-sequences.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Montagem de sequências</span>"
    ]
  },
  {
    "objectID": "montagem.html#alinhamento-de-contigs",
    "href": "montagem.html#alinhamento-de-contigs",
    "title": "Montagem de sequências",
    "section": "Alinhamento de contigs",
    "text": "Alinhamento de contigs\nContigs\nConjunto de sobreposições entre as fitas-simples oriundas de cada primer para formar uma sequência de consenso.\n\nAssembly softwares\nA partir do rastro da intensidade dos sinais de cada uma das quatro bases nucleotídicas (raw trace), um programa de computador processa através do processo denominado base calling, que reconhece os picos nas intensidades do sinal de cada base.\nDentre os programas que realizam o base calling para montagem das sequências estão: Geneious, Sequencher, CodonCode Aligner, ChromasPRO, DNA Baser; mas também os open-source: Staden Package e o pacote Phred/Phrap/Consed.\nExistem diversos algoritmos para montagem de sequência , dentre os quais, destaca-se: CAP3, PHRAP, TIGR. Os algoritmos de montagem de genoma são conjuntos de procedimentos bem definidos necessários para reconstruir sequências de DNA a partir de dois ou um grande número de fragmentos mais curtos de uma sequência de DNA. Os fragmentos são alinhados uns ao lado dos outros pelo reconhecimento das regiões que apresentam sobreposição (contigs). Essas regiões de contigs são identificadas e mescladas. Algoritmos para reconstruir o genoma completo a partir de milhares de fragmentos como na tecnologia next-generation também têm sido desenvolvidos.\n\n\n\nPrática\nPara essa atividade será preciso baixar um dos programas que realizam essa tarefa. Contudo, esses programas possuem licenças pagas. Entretanto, as empresas oferecem um período de teste com todas as funcionalidades ativas. Sugestão para essa atividade: Sequencher, Geneious ou CodonCode Aligner.\n\nVamos utilizar os arquivos listados abaixo, que compõem quatro primers sequenciados do locus trnD-trnT de um organismo desconhecido (species 1):\n\nspecies_1_trnD-T(T).ab1\nspecies_1_trnD-T(E).ab1\nspecies_1_trnD-T(Y).ab1\nspecies_1_trnD-T(D).ab1\n\nSiga o passo-a-passo:\n\nAbra esses arquivos no programa escolhido.\nExecute a função para realizar a montagem dos primers (assemble).\nInspecione visualmente a montagem dos primers do início ao fim.\nInterprete os cromatogramas e as respectivas sequências e edite manualmente os erros encontrados.\nFinalmente, teremos a sequência consenso montada.\nNão deixe de salvar o arquivo da montagem no software utilizado. Após a etapa do alinhamento, o filogeneticista terá de reconferir essas montagens.\n\nCompare a sua montagem com esta, realizada no programa Sequencher:\n\nspecies_1_trnD-T.SPF\n\n\n\n\nFaça também a montagem do ITS:\n\nspecies_2_ITS(An4).ab1\nspecies_2_ITS(An5).ab1\n\nCompare a sua montagem do ITS com esta, realizada no programa Sequencher:\n\nspecies_2_ITS.SPF\n\n\n\nMonte as sequências usando os arquivos .ab1 em: https://www.vanderbilt.edu/wolbachiaproject/lab-5-dna-sequences.\n\n\n\n\nCornish-Bowden, A. 1985. «Nomenclature for incompletely specified bases in nucleic acid sequences: recommendations 1984». Nucleic Acids Research 13 (9): 3021–30. https://doi.org/10.1093/nar/13.9.3021.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Montagem de sequências</span>"
    ]
  },
  {
    "objectID": "formatos.html",
    "href": "formatos.html",
    "title": "Formatos de arquivo mais comuns",
    "section": "",
    "text": "PHYLIP",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Formatos de arquivo mais comuns</span>"
    ]
  },
  {
    "objectID": "formatos.html#phylip",
    "href": "formatos.html#phylip",
    "title": "Formatos de arquivo mais comuns",
    "section": "",
    "text": "Lançado em 1980 por Joe Felsenstein.\n\n\n3 62\nMimosa_afranioi ----------------------------------------CATTCAAACCTTTTTTA-----\nMimosa_campicola --------------------------------------TTCATTCAAACCTTTTTTA----\nMimosa_candollei CCAGGAAAAAAGTGTACAGCATGCATATTCTTA-CGATTTCATTCAAACCTTTTCTA----",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Formatos de arquivo mais comuns</span>"
    ]
  },
  {
    "objectID": "formatos.html#fasta",
    "href": "formatos.html#fasta",
    "title": "Formatos de arquivo mais comuns",
    "section": "FASTA",
    "text": "FASTA\n\nLançado em 1985 por David Lipman e William R. Pearson.\nFormato mais simples para sequências nucleotídicas ou proteicas.\nO nome do terminal ou a etiqueta (label) é precedida pelo caractere do sinal de maior &gt;.\nAdmite o caractere vazio (gap): -.\nExtensões usadas: .fas, .fasta.\n\n&gt;Mimosa_afranioi\n----------------------------------------CATTCAAACCTTTTTTA---\n--TTTCGATTTTAGATTAGAATTGTCTTGTTCTAACTGGCGGAGGCGGGACTAATATGTT\nGATATTTAT----------ATTTATATAGATATAGATTTATA-------------TGGAT\n&gt;Mimosa_campicola\n--------------------------------------TTCATTCAAACCTTTTTTA---\n--TTTAGATT--AGAATAGAATTGTCTTGTTCTAACTGGCGGAGGCGGGACTAATATGTT\nGATATTTATATAGATATAGATTTATATAGATATAGATTTATA-------------TGGAT\n&gt;Mimosa_candollei\nCCAGGAAAAAAGTGTACAGCATGCATATTCTTA-CGATTTCATTCAAACCTTTTCTA---\n--TTTCGATTTTAGATTCGAATTGTCTTGTTCTAACTGGCGGAGGCGGGACTAATATGTT\nGATATTTAT----------ATTTAT------ATAGATTTATA-------------TGTAT",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Formatos de arquivo mais comuns</span>"
    ]
  },
  {
    "objectID": "formatos.html#nexus",
    "href": "formatos.html#nexus",
    "title": "Formatos de arquivo mais comuns",
    "section": "NEXUS",
    "text": "NEXUS\n\nLançado em 1987 por Wayne & David Maddison e David L. Swofford ^(criador do PAUP)^.\n\n\nr Citet(referencias, \"Maddison\")\n#NEXUS\nBEGIN TAXA;\n    TITLE Taxa;\n    DIMENSIONS NTAX=3;\n    TAXLABELS\n        afranioi campicola candollei;\nEND;\nBEGIN CHARACTERS;\n    TITLE  Character_Matrix;\n    DIMENSIONS  NCHAR=62;\n    FORMAT DATATYPE = DNA GAP = - MISSING = ?;\n    MATRIX\nMimosa_afranioi ---------------------------------------CATTCAAACCTTTTTTA-----\nMimosa_campicola    --------------------------------------TTCATTCAAACCTTTTTTA----\nMimosa_candollei    CCAGGAAAAAAGTGTACAGCATGCATATTCTTA-CGATTTCATTCAAACCTTTTCTA----\n;\nEND;\n\n\n\nMaddison, W.P. & Maddison, D.R., 1992. MacClade: Analysis of Phylogeny and Character Evolution. Version 3\n\n\n\nMaddison, W.P. & Maddison, D.R., 2002. Mesquite: a modular system for evolutionary analysis. Version 0.991. http://mesquiteproject.org",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Formatos de arquivo mais comuns</span>"
    ]
  },
  {
    "objectID": "genebank.html",
    "href": "genebank.html",
    "title": "GeneBank Blast",
    "section": "",
    "text": "Baixando sequências do GeneBank\nBuscar e baixar sequências\nNational Center for Biotechnology Information",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>GeneBank *Blast*</span>"
    ]
  },
  {
    "objectID": "genebank.html#preparando-os-arquivos-das-sequências",
    "href": "genebank.html#preparando-os-arquivos-das-sequências",
    "title": "GeneBank Blast",
    "section": "Preparando os arquivos das sequências",
    "text": "Preparando os arquivos das sequências\n\nExpressões regulares\nRegEx\n\nPrática",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>GeneBank *Blast*</span>"
    ]
  },
  {
    "objectID": "alinhamento.html",
    "href": "alinhamento.html",
    "title": "Alinhamento manual",
    "section": "",
    "text": "Caso o Geneious esteja operando sem restrições, o alinhamento manual poderá ser executado no próprio software.\nCaso tenha utilizado o Geneious com restrição de uso, ele não poderá realizar o alinhamento manual. Portanto, abra o arquivo alinhamento.fasta e realize o alinhamento manual no programa BioEdit.\nEssa é a etapa em que as homologias moleculares serão codificadas. Cada locus representará um caráter na matriz. Nenhum alinhamento múltiplo automático garante um alinhamento perfeito, principalmente devido às lacunas (gaps) produzidas pelos indels durante o alinhamento. Por isso, vamos realizar o alinhamento manual utilizando o BioEdit a partir do arquivo gerado pelo alinhamento automático.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Alinhamento manual</span>"
    ]
  },
  {
    "objectID": "indels.html",
    "href": "indels.html",
    "title": "Codificando indels",
    "section": "",
    "text": "SIC\nUm fato geralmente observado após um alinhamento múltiplo, são as lacunas na matriz já alinhada. Essas lacunas são denominadas indels, que significa uma junção dos sufixos: inserções e deleções. Esses indels podem ser observados apenas nessa etapa, já que apenas através da comparação entre sequências é que podemos reconhecer uma mutação por inserção e deleções. O padrão de indels também pode ser informativos de parentesco. Existem métodos para codificação de indels (SIC, MCIC, 5th state) que também podem ser adicionados na matriz final. O software SeqState Müller (2005) é um programa open-source, eficiente, com interface simples, desenvolvido em Java, que pode ser utilizado para codificação automática de indels a partir dos três métodos.\nBinário",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Codificando indels</span>"
    ]
  },
  {
    "objectID": "indels.html#mcic",
    "href": "indels.html#mcic",
    "title": "Codificando indels",
    "section": "MCIC",
    "text": "MCIC\nMultiestados",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Codificando indels</span>"
    ]
  },
  {
    "objectID": "indels.html#prática",
    "href": "indels.html#prática",
    "title": "Codificando indels",
    "section": "Prática",
    "text": "Prática\n\n\n\n\nMüller, K. 2005. «SeqState: Primer Design and Sequence Statistics for Phylogenetic DNA Datasets». Applied Bioinformatics 4 (1): 65–69. https://doi.org/10.2165/00822942-200504010-00008.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Codificando indels</span>"
    ]
  },
  {
    "objectID": "concatenacao.html",
    "href": "concatenacao.html",
    "title": "Concatenando matrizes",
    "section": "",
    "text": "Prática: RegEx 2\nO software SequenceMatrix Vaidya, Lohman, e Meier (2011) é um programa open-source, simples, desenvolvido em Java, para concatenar matrizes distintas, mesclando sequências com mesmo nome em diferentes arquivos (matrizes).\nO arquivo .nex resultante do procedimento de codificação do SeqState precisa ser aberto em um editor de texto mais especializado para programação. Experimente o Notepad2.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Concatenando matrizes</span>"
    ]
  },
  {
    "objectID": "concatenacao.html#prática-regex-2",
    "href": "concatenacao.html#prática-regex-2",
    "title": "Concatenando matrizes",
    "section": "",
    "text": "Vaidya, G., D. J. Lohman, e R. Meier. 2011. «SequenceMatrix: concatenation software for the fast assembly of multi-gene datasets with character set and codon information». Cladistics 27 (2): 171–80. https://doi.org/10.1111/j.1096-0031.2010.00329.x.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Concatenando matrizes</span>"
    ]
  },
  {
    "objectID": "modelos.html",
    "href": "modelos.html",
    "title": "Modelos de evolução de sequências",
    "section": "",
    "text": "As 6 substituições\n(Holmes2001?)",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Modelos de evolução de sequências</span>"
    ]
  },
  {
    "objectID": "modelos.html#as-6-substituições",
    "href": "modelos.html#as-6-substituições",
    "title": "Modelos de evolução de sequências",
    "section": "",
    "text": "Substituições do tipo transição são mais frequentes que transversões.\n\nTransição:\n\nEntre purinas: adenina (A) e guanina (G);\nEntre pirimidinas: citosina (C) e timina (T).\n\nTransversões:\n\nEntre purinas e pirimidinas.\n\n\nAdemais, as mutações silenciosas são mais frequentes do que:\n\nMutações de sentido errado (missense) ou não sinônimas;\n\nResulta na substituição de um aminoácido por outro.\n\nMutações sem sentido (nonsense).\n\nOcorre um substituição de um par de nucleotídeos dentro de uma região codificante de proteína que muda um códon para um aminoácido em um códon de término.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Modelos de evolução de sequências</span>"
    ]
  },
  {
    "objectID": "modelos.html#modelo-jukescantor-jc-1969",
    "href": "modelos.html#modelo-jukescantor-jc-1969",
    "title": "Modelos de evolução de sequências",
    "section": "Modelo Jukes/Cantor (JC) 1969",
    "text": "Modelo Jukes/Cantor (JC) 1969\n\nAssume que as bases ocorrem com igual frequência e a taxa de substituição de uma base para qualquer outra é a mesma.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Modelos de evolução de sequências</span>"
    ]
  },
  {
    "objectID": "modelos.html#modelo-kimura-k80-1980",
    "href": "modelos.html#modelo-kimura-k80-1980",
    "title": "Modelos de evolução de sequências",
    "section": "Modelo Kimura (K80) 1980",
    "text": "Modelo Kimura (K80) 1980\n\nReferido como “modelo de dois parâmetros de Kimura”\nAssume frequências distintas para transições e transversões",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Modelos de evolução de sequências</span>"
    ]
  },
  {
    "objectID": "modelos.html#modelo-hasegawa-kishino-yano-hky-1985",
    "href": "modelos.html#modelo-hasegawa-kishino-yano-hky-1985",
    "title": "Modelos de evolução de sequências",
    "section": "Modelo Hasegawa-Kishino-Yano (HKY) 1985",
    "text": "Modelo Hasegawa-Kishino-Yano (HKY) 1985\n\nDistingue entre a taxa de transições e transversões (usando o parâmetro κ), e permite frequências de base desiguais.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Modelos de evolução de sequências</span>"
    ]
  },
  {
    "objectID": "modelos.html#modelo-general-time-reversible-gtr-1986",
    "href": "modelos.html#modelo-general-time-reversible-gtr-1986",
    "title": "Modelos de evolução de sequências",
    "section": "Modelo General Time Reversible (GTR) 1986",
    "text": "Modelo General Time Reversible (GTR) 1986\n\nModelo de substituição mais utilizado.\nModelo mais neutro, independente, de sítios finitos e reversível no tempo\nTodos seis tipos de substituição têm taxas diferentes",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Modelos de evolução de sequências</span>"
    ]
  },
  {
    "objectID": "softwares.html",
    "href": "softwares.html",
    "title": "Softwares para análises filogenéticas",
    "section": "",
    "text": "MS-DOS\nDesde 1980, uma série de softwares vem sendo desenvolvidos para rodar análises filogenéticas.\nPhylip\nHennig86\nNONA\nBase atualizada com lista de programas por seções.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Softwares para análises filogenéticas</span>"
    ]
  },
  {
    "objectID": "softwares.html#ms-dos",
    "href": "softwares.html#ms-dos",
    "title": "Softwares para análises filogenéticas",
    "section": "",
    "text": "Diversos programas de análises filogenéticas foram desenvolvidos para o ambiente do DOS (Disk Operating System).\nO prompt de comando do DOS shell é representado por C:\\&gt;.\n\nA letra C refere-se à unidade de disco;\nOs dois-pontos e a contra-barra indicam o caminho do diretório-raiz da unidade C.\n\n\n\nSeleção do driver\n\nc:\n\nAcessa um diretório a partir do diretório atual:\n\ncd [diretório]\n\nRetorna um diretório:\n\ncd..\n\nRetorna ao diretório-raiz da unidade de disco:\n\ncd/\n\nAcessa um diretório:\n\ncd/[diretório]\n\nExibe os diretórios e arquivos locais:\n\ndir\n\n…, lado a lado:\n\ndir/w\n\n…, pausadamente:\n\ndir/p\n\n…, lado a lado, pausadamente:\n\ndir/w/p\n\nMostra todos os arquivos com determinada extensão:\n\ndir *.[extensão]\n\nMostra os argumentos da função dir:\n\ndir/?",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Softwares para análises filogenéticas</span>"
    ]
  },
  {
    "objectID": "softwares.html#iq-tree",
    "href": "softwares.html#iq-tree",
    "title": "Softwares para análises filogenéticas",
    "section": "IQ-TREE",
    "text": "IQ-TREE\n\nO IQ-TREE é um dos programas mais utilizados para condução de análises filogenéticas baseada no método da Máxima verossimilhança.\nVeja o Manual\nA primeira versão foi lançada em 2011. O IQ-Tree é o sucessor dos softwares IQPNNI (desde 2004) e do TREE-PUZZLE (desde 1995).\n\n\n\nPrática\n\nVamos testar o IQ-TREE utilizando o exemplo embutido no programa:\n\n\n\nColoque os arquivo com a matriz alinhada no mesmo diretório que o programa IQ-Tree. Isso evita que se tenha de especificar o caminho do arquivo a ser lido (input).\nRealize uma análise-teste com o exemplo do próprio programa, o arquivo example.phy, mas antes abra-o em um editor de texto plano (como o Bloco de Notas do Windows) para verificar seu conteúdo.\nEm seguida, execute os comandos abaixo:\n\nLista completa de funções do programa\n\niqtree -h\n\nInferir a árvore de máxima verossimilhança utilizando o melhor modelo selecionado pelo ModelFinder\n\niqtree -s example.phy\n\nExecutar apenas a busca pelo melhor modelo utilizando o ModelFinder\n\niqtree -s example.phy -m MF\n\nExecutar diferentes métodos para estimação do suporte dos ramos\n\niqtree -s example.phy -alrt 10000 -bb 10000 -lbp 10000 -abayes\n\n\n\nExemplo com dados particionados (matriz combinada)\n\nArquivo input\n\niqtree -spp mimosa.nex\n\nReescrever os arquivos, apagando os dados previamente gerados\n\niqtree -spp mimosa.nex -redo\n\nSeleção do terminal externo\n\niqtree -spp mimosa.nex -redo -o Mimosa_invisa_invisa\n\nMétricas de suporte dos ramos\n\niqtree -spp mimosa.nex -redo -o invisa_invisa -allnni -alrt 10000 -bb  10000 -lbp 10000 -abayes -bnni\n\nEstabelecendo constraints\n\niqtree -spp mimosa.nex -redo -o invisa_invisa -g mimosa.constr1\n\nConcatenar arquivos\n\ntype mimosa0.nex.treefile mimosa1.nex.treefile mimosa2.nex.treefile mimosa3.nex.treefile &gt; mimosa.treels\n\nExecutar os testes de topologia\n\niqtree -spp mimosa.nex -z mimosa.treels -o invisa_invisa -allnni -alrt 10000 -bb 10000 -abayes -lbp 10000 -bsam GENESITE -zb 10000 -au -zw",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Softwares para análises filogenéticas</span>"
    ]
  },
  {
    "objectID": "softwares.html#splitstree6",
    "href": "softwares.html#splitstree6",
    "title": "Softwares para análises filogenéticas",
    "section": "SplitsTree6",
    "text": "SplitsTree6\n\nPrática\n\nO arquivo .splits.nex gerado pelo IQ-TREE pode ser carregado pelo SplitsTree6 Huson e Bryant (2005), um programa com interface gráfica com usuário e simples de usar.\nDiferentemente das árvores filogenéticas, as redes filogenéticas conseguem representar as incongruências e incertezas do conjunto total de árvores obtidas na análise filogenética, e são produzidas a partir de métodos de distância específicos. Trata-se de uma ferramenta exploratória interessante que tem sido utilizada até mesmo fora do campo da biologia comparativa.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Softwares para análises filogenéticas</span>"
    ]
  },
  {
    "objectID": "softwares.html#mrbayes",
    "href": "softwares.html#mrbayes",
    "title": "Softwares para análises filogenéticas",
    "section": "MrBayes",
    "text": "MrBayes\n\nA primeira versão do MrBayes Huelsenbeck e Ronquist (2001) foi lançada em 2000. Este talvez seja o mais conhecido programa de análise bayesiana para filogenias.\nO MrBayes possui um console próprio onde são inseridas as linhas de comando.\n\n\n\nO ideal é manter o arquivo da matriz de dados a ser analisada no mesmo diretório do MrBayes.\n\n\nPrática 1\n\nAbra o MrBayes e execute os comandos abaixo:\n\nSobre o programa:\n\nabout\n\nCitações dos diferentes módulos do programa:\n\ncitations\n\nGera um arquivo .txt com a referência completa das funções no diretório Documents:\n\nmanual\n\nExibe as principais funções do programa:\n\nhelp\n\n\nCom a função “help” os diversos parâmetros são exibidos:\n\nExibe explicação e os parâmetros do modelo de verossimilhança:\n\nhelp lset\n\nExibe explicação e os parâmetros a prioris do modelo filogenético:\n\nhelp prset\n\nExibe explicação e os parâmetros da análise MCMC:\n\nhelp mcmc\n\nExibe explicação e os parâmetros da função sump:\n\nhelp sump\n\nExibe explicação e os parâmetros da função sumt:\n\nhelp sumt\n\n\nExecute uma análise filogenética utilizando o exemplo trazido pelo próprio MrBayes, o arquivo primatex.nex:\n\nCarrega dados do arquivo NEXUS\n\nexecute primates.nex\n\nAltera o modelo evolutivo para GTR+G+I (Variação na taxa de substituição entre sítios de nucleotídeos proporção de sítios invariáveis)\n\nlset nst 6 rates=invgamma\n\nConferir os parâmetros do modelo\n\nshowmodel\n\nPara alterar os parâmetros do modelo, use prset, indique o nome do parâmetro, insira o símbolo de igual “=”, e indique o valor\n\nprset\n\nInicia a análise Monte Carlo via cadeias de Markov alterando alguns parâmetros\n\nmcmc ngen=20000 samplefreq=100 printfreq=100 diagnfreq=1000\n\nResume os valores dos parâmetros usando o mesmo burn-in que o diagnóstico no comando “mcmc”\n\nsump\n\nResume as árvores usando o mesmo burn-in que o comando mcmc\n\nsumt\n\n\n\n\n\nPrática 2: Modelo de substituição\n\nPara especificação do modelo evolutivo, use o comando lset\nOs parâmetros de modelo mais utilizads são:\n\nnúmero de tipos de substituição\n\n\n1 = Jukes-Cantor\n2 = HKY\n6 = GTR\n\n\nmodelo de variação de taxa entre sítios (sites)\n\n\nI = Taxas de sítios invariáveis\nG = Taxas de distribuição gama entre os sítios\nI+G = Combinação\n\nPara configurar o modelo GTR+G, use:\n\n\nlset nst=6 rates=gamma\n\n\nPara configurar o modelo GTR+G+I, use:\n\n\nlset nst=6 rates=invgamma\n\n\nO modelo de GTR+I+G geralmente se ajusta melhor aos dados.\n\nFonte: http://treethinkers.org/tutorials/mrbayes\n\nNa versão mais recente do MrBayes (3.2.2) é possível evitar ter que especificar apenas um esquema de tipos de substituição, permitindo que MrBayes se mova por diferentes esquemas como parte de sua amostragem MCMC. Este procedimento é conhecido como salto reversível MCMC (RJ-MCMC).\nPara configurar o salto reversível, use o seguinte comando:\n\n\nlset nst=mixed rates=gamma\n\n\nO salto reversível não está configurado atualmente para diferentes modelos de variação de taxa entre sítios.\n\n\n\nPrática 3: Gerando o output\n\nDepois de executar uma análise MCMC no MrBayes, certifique-se de que as cadeias de Markov convergiram através do software Tracer.\nExclua as amostras influenciadas pelo ponto de partida de uma análise MCMC através de um processo conhecido como descarte do burn-in.\nA remoção do burn-in é feita especificando um valor para o parâmetro burnin de sump e sumt:\n\n\nsump burnin=1000\n\n\n\nsumt burnin=1000",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Softwares para análises filogenéticas</span>"
    ]
  },
  {
    "objectID": "softwares.html#softwares-para-seleção-de-modelos-evolutivos",
    "href": "softwares.html#softwares-para-seleção-de-modelos-evolutivos",
    "title": "Softwares para análises filogenéticas",
    "section": "Softwares para seleção de modelos evolutivos",
    "text": "Softwares para seleção de modelos evolutivos",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Softwares para análises filogenéticas</span>"
    ]
  },
  {
    "objectID": "softwares.html#raxmlgui-2.0-jmodeltest-2",
    "href": "softwares.html#raxmlgui-2.0-jmodeltest-2",
    "title": "Softwares para análises filogenéticas",
    "section": "raxmlGUI 2.0 + jModelTest 2",
    "text": "raxmlGUI 2.0 + jModelTest 2\nhttps://antonellilab.github.io/raxmlGUI/\n\nPartitionFinder\nPartitionFinder  Os principais resultados são gravados no arquivo best_scheme.txt.\n\n\n\n\nHuelsenbeck, John P., e Fredrik Ronquist. 2001. «MRBAYES: Bayesian inference of phylogenetic trees». Bioinformatics 17 (8): 754–55. https://doi.org/10.1093/bioinformatics/17.8.754.\n\n\nHuson, Daniel H., e David Bryant. 2005. «Application of Phylogenetic Networks in Evolutionary Studies». Molecular Biology and Evolution 23 (2): 254–67. https://doi.org/10.1093/molbev/msj030.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Softwares para análises filogenéticas</span>"
    ]
  },
  {
    "objectID": "edicao-arvores.html",
    "href": "edicao-arvores.html",
    "title": "Edição final de árvore",
    "section": "",
    "text": "Prática\nHá uma gama muito grande de softwares que editam árvores filogenéticas. O programa FigTree possui interface amigável com usuário e com ele é possível editar árvores publicáveis. Outros programas que possuem interface gráfica com usuário são: Dendroscope e o Mesquite (que possui diversas funcionalidades voltadas para filogenias).\nNo presente curso aprenderemos a editar árvores usando o , cujas possibilidades e funcionalidades superam hoje qualquer software com interface gráfica.\nNessa etapa, vamos utilizar o programa o FigTree para, em seguida, aprendermos o básico do  e seus pacotes de filogenia.\nAbra as árvores obtidas nas análises filogenéticas previamente executadas com o FigTree e experimente as possibilidades de edição.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Edição final de árvore</span>"
    ]
  },
  {
    "objectID": "arvores-plantas.html",
    "href": "arvores-plantas.html",
    "title": "Árvores filogenéticas das plantas",
    "section": "",
    "text": "https://github.com/camwebb/tree-of-trees\nÁrvore de Gastauer e Neto (2017): R20160415.new\nLi et al. (2021)\n353 Protein Coding Genes Johnson et al. (2018)\nPlant and Fungal Trees of Life (PAFTOL) project: https://www.kew.org/science/our-science/projects/plant-and-fungal-trees-of-life\n\n\n\n\nGastauer, Markus, e João Augusto Alves Meira Neto. 2017. «Updated angiosperm family tree for analyzing phylogenetic diversity and community structure». Acta Botanica Brasilica 31 (2): 191–98. https://doi.org/10.1590/0102-33062016abb0306.\n\n\nJohnson, Matthew G, Lisa Pokorny, Steven Dodsworth, Laura R Botigué, Robyn S Cowan, Alison Devault, Wolf L Eiserhardt, et al. 2018. «A Universal Probe Set for Targeted Sequencing of 353 Nuclear Genes from Any Flowering Plant Designed Using k-Medoids Clustering». Editado por Susanne Renner. Systematic Biology 68 (4): 594–606. https://doi.org/10.1093/sysbio/syy086.\n\n\nLi, Hong-Tao, Yang Luo, Lu Gan, Peng-Fei Ma, Lian-Ming Gao, Jun-Bo Yang, Jie Cai, et al. 2021. «Plastid phylogenomic insights into relationships of all flowering plant families». BMC Biology 19 (1). https://doi.org/10.1186/s12915-021-01166-2.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Árvores filogenéticas das plantas</span>"
    ]
  },
  {
    "objectID": "introducao-r.html",
    "href": "introducao-r.html",
    "title": "Introdução ao R",
    "section": "",
    "text": "Programação orientada a objetos",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "introducao-r.html#programação-orientada-a-objetos",
    "href": "introducao-r.html#programação-orientada-a-objetos",
    "title": "Introdução ao R",
    "section": "",
    "text": "Programação orientada a objetos.\nTudo no  são objetos.\nObjetos possuem uma estrutura de dados que armazenam variáveis.\nVariáveis armazenam valores ou conjunto de valores de acordo com o tipo dos dados\nAs variáveis populam estruturas de dados.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "introducao-r.html#principais-estruturas-de-dados",
    "href": "introducao-r.html#principais-estruturas-de-dados",
    "title": "Introdução ao R",
    "section": "Principais estruturas de dados",
    "text": "Principais estruturas de dados\nAs variáveis são armazenadas em tipos de estruturas de dados:\n\nvetores\nlistas\nmatrizes\ndataframes\narrays\n\n\n\nFunções são também são objetos, mas executam um conjunto operações determinadas.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "introducao-r.html#principais-tipos-de-dados",
    "href": "introducao-r.html#principais-tipos-de-dados",
    "title": "Introdução ao R",
    "section": "Principais tipos de dados",
    "text": "Principais tipos de dados\nAs váriáveis pode ser de diferentes tipos:\n\nnumeric\n\ninteger, double\n\ncharacter\n\nstring\n\nlogical\n\nTRUE, FALSE\n\nfactor\n\nvariáveis categóricas\nnº limitado de valores\nníveis do fator",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "introducao-r.html#classe-x-propriedade-x-atributo",
    "href": "introducao-r.html#classe-x-propriedade-x-atributo",
    "title": "Introdução ao R",
    "section": "Classe x propriedade x atributo",
    "text": "Classe x propriedade x atributo\n\nTodo objeto tem uma classe.\n\nDiz-se que um objeto é uma instância de uma classe.\n\nUma classe contém propriedades.\n\nO valor que cada propriedade assume em um objeto é chamado de atributo.\n\n\n\n\n\n\n\nOutras classes podem ser definidas.\n\n\nSistema de referência\n\nNo R, há um sistema de referência de classes.\n\n\n\n\n\n\n\n\nClasse S3\nClasse S4\n\n\n\n\nAtributos são acessados usando $\nAtributos são acessados usando @",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "introducao-r.html#linguagem-r",
    "href": "introducao-r.html#linguagem-r",
    "title": "Introdução ao R",
    "section": "Linguagem R",
    "text": "Linguagem R\n\nTudo após # não é lido pelo R. Este é um caractere de comentário.\nO  diferencia maiúsculas de minúsculas.\nHá uma série de operadores pré-programados.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "introducao-r.html#console",
    "href": "introducao-r.html#console",
    "title": "Introdução ao R",
    "section": "Console",
    "text": "Console\n\nO console do  refere-se ao ambiente de desenvolvimento e o prompt de comando (command prompt) é a linha de inserção de comando. O símbolo no prompt de comando é o “&gt;”, porém ele também muda para “+” quando há a entrada de um comando incompleto. Com o sinal de +, o console indica que aguarda a completude do comando inserido.\nTudo após o símbolo “#” não é lido pelo R. Esse é o caráter para introdução de notas e comentários.\nO  diferencia maiúsculas de minúsculas.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "introducao-r.html#criando-objetos",
    "href": "introducao-r.html#criando-objetos",
    "title": "Introdução ao R",
    "section": "Criando objetos",
    "text": "Criando objetos\nPara atribuir um valor a um objeto, utilize o operador &lt;- (ou =):\n\nx &lt;- 4\nx\n\n[1] 4\n\ny = 5\nx + y\n\n[1] 9",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "introducao-r.html#funções",
    "href": "introducao-r.html#funções",
    "title": "Introdução ao R",
    "section": "Funções",
    "text": "Funções\n\nSintaxe da função\n\nfunção()\nfunção(argumento1 = valor, argumento2 = valor, ...)\n\nVamos criar uma função como exemplo:\n\nfunção &lt;- function(arg1 = \"\", arg2 = \"\"){\n  \n  Código_da_função\n  \n}\n\nVamos observar os argumentos da função com a função args()\n\nargs(função) # Mostra os argumentos da função `função`\n\nfunction (arg1 = \"\", arg2 = \"\") \nNULL\n\n\n\n\nFunções básicas\nVersão, licença e citação:\n\nR.Version() # mostra a versão\n\n$platform\n[1] \"x86_64-w64-mingw32\"\n\n$arch\n[1] \"x86_64\"\n\n$os\n[1] \"mingw32\"\n\n$crt\n[1] \"ucrt\"\n\n$system\n[1] \"x86_64, mingw32\"\n\n$status\n[1] \"\"\n\n$major\n[1] \"4\"\n\n$minor\n[1] \"2.2\"\n\n$year\n[1] \"2022\"\n\n$month\n[1] \"10\"\n\n$day\n[1] \"31\"\n\n$`svn rev`\n[1] \"83211\"\n\n$language\n[1] \"R\"\n\n$version.string\n[1] \"R version 4.2.2 (2022-10-31 ucrt)\"\n\n$nickname\n[1] \"Innocent and Trusting\"\n\nlicense() # informações sobre a licença\n\n\nThis software is distributed under the terms of the GNU General\nPublic License, either Version 2, June 1991 or Version 3, June 2007.\nThe terms of version 2 of the license are in a file called COPYING\nwhich you should have received with\nthis software and which can be displayed by RShowDoc(\"COPYING\").\nVersion 3 of the license can be displayed by RShowDoc(\"GPL-3\").\n\nCopies of both versions 2 and 3 of the license can be found\nat https://www.R-project.org/Licenses/.\n\nA small number of files (the API header files listed in\nR_DOC_DIR/COPYRIGHTS) are distributed under the\nLESSER GNU GENERAL PUBLIC LICENSE, version 2.1 or later.\nThis can be displayed by RShowDoc(\"LGPL-2.1\"),\nor obtained at the URI given.\nVersion 3 of the license can be displayed by RShowDoc(\"LGPL-3\").\n\n'Share and Enjoy.'\n\ncitation() # como citar\n\n\nTo cite R in publications use:\n\n  R Core Team (2022). R: A language and environment for statistical\n  computing. R Foundation for Statistical Computing, Vienna, Austria.\n  URL https://www.R-project.org/.\n\nA BibTeX entry for LaTeX users is\n\n  @Manual{,\n    title = {R: A Language and Environment for Statistical Computing},\n    author = {{R Core Team}},\n    organization = {R Foundation for Statistical Computing},\n    address = {Vienna, Austria},\n    year = {2022},\n    url = {https://www.R-project.org/},\n  }\n\nWe have invested a lot of time and effort in creating R, please cite it\nwhen using it for data analysis. See also 'citation(\"pkgname\")' for\nciting R packages.\n\n\nFunções de ajuda:\n\nhelp() # função ajuda\n\nstarting httpd help server ... done\n\nhelp.start() # Manuais e outros materiais\n\nIf nothing happens, you should open\n'http://127.0.0.1:30808/doc/html/index.html' yourself\n\nhelp(base) # Manual do pacote \"base\"\n\nFunções de data e hora:\n\nSys.time() # Obtém data e horário exatos do sistema\n\n[1] \"2025-04-27 11:27:27 -03\"",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "introducao-r.html#pacotes",
    "href": "introducao-r.html#pacotes",
    "title": "Introdução ao R",
    "section": "Pacotes",
    "text": "Pacotes\nPacotes mais baixados:\n\n\nWarning: package 'xaringanExtra' was built under R version 4.2.3\n\n\n\n\n\n\n\n\nPacotes mais baixados em tempo real:",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "introducao-r.html#prática",
    "href": "introducao-r.html#prática",
    "title": "Introdução ao R",
    "section": "Prática",
    "text": "Prática\n\nIndexação de objetos\n\nx &lt;- 4 # cria o objeto \"x\" atribuindo o valor \"4\"\nx # Observe o objeto criado\n\n[1] 4\n\n\nPara concatenar vários valores utilize a função c:\nConcatenar vários valores e atribuí-los a um objeto:\n\nx &lt;- c(4, 5, 6, 7, 8)\nx # Observe o objeto criado\n\n[1] 4 5 6 7 8\n\n\nExtrair um ou vários valores de um objeto a partir da indexação:\n\nx[3]\n\n[1] 6\n\nx[c(1, 4)]\n\n[1] 4 7\n\n\nSubstitua valores de um objeto a partir da indexação:\n\ny &lt;- c(24, 10, 45, 56, 20, 29, 50, 67, 80, 23, 20, 15, 65, 57, 34, 63, 20)\ny[y==20] &lt;- 10 # Se algum valor de y é igual a 20, substituir por 10\ny\n\n [1] 24 10 45 56 10 29 50 67 80 23 10 15 65 57 34 63 10\n\ny[y==10] &lt;- \"NA\" # Apaga todos os valores iguais a 10, substituindo por \"NA\"\ny\n\n [1] \"24\" \"NA\" \"45\" \"56\" \"NA\" \"29\" \"50\" \"67\" \"80\" \"23\" \"NA\" \"15\" \"65\" \"57\" \"34\"\n[16] \"63\" \"NA\"\n\n\nDeleta o objeto:\n\nrm(x)\n\nPode-se criar objetos com valores numéricos (numeric), conforme mostrado até aqui, mas também objetos com valores de caracteres (character), lógicos (logical) ou fatores (factor).\nObjetos do tipo character podem ser criados utilizando aspas (” “) entre os valores incluídos. Um objeto do tipo factor cria categorias para cada valor encontrado no objeto. Geralmente são usados em diversos pacotes para análises filogenéticas:\n\ncharacter &lt;-c(\"apical\", \"apical\", \"basal\", \"apical\", \"apical\", \"basal\", \"median\")\ncharacter\n\n[1] \"apical\" \"apical\" \"basal\"  \"apical\" \"apical\" \"basal\"  \"median\"\n\ncharact_fact &lt;- factor(character)\ncharact_fact\n\n[1] apical apical basal  apical apical basal  median\nLevels: apical basal median\n\n\n\n\nOperadores de lógica\n\n\n\n\n&lt; |\nless than |\n\n\n\n\n&lt;=\n| less than or equal to |\n\n\n\n\n\n\n&gt; |\ngreater than |\n\n\n\n\n&gt;=\n| greater than or equal to |\n\n\n\n\n\n\n== |\nexactly equal to |\n\n\n\n\n!= |\nnot equal to |\n\n\n\n\n\n\n!x |\nnot x |\n\n\n\n\nx |\ny | x OR y |\n\n\n\nx & y | x AND y | ——– ———\n\nVamos testar:\n\nx &lt;- c(1:10)\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nx[(x&gt;8) | (x&lt;5)]\n\n[1]  1  2  3  4  9 10\n\n# Qual a lógica?\nx &gt; 8\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n\nx &lt; 5\n\n [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\nx &gt; 8 | x &lt; 5\n\n [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE\n\nx[c(T, T, T, T, F, F, F, F, T, T)]\n\n[1]  1  2  3  4  9 10\n\n\nExperimente a utilização dos operadores matemáticos simples entre diferentes objetos:\n\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\ny\n\n [1] \"24\" \"NA\" \"45\" \"56\" \"NA\" \"29\" \"50\" \"67\" \"80\" \"23\" \"NA\" \"15\" \"65\" \"57\" \"34\"\n[16] \"63\" \"NA\"\n\n\n\n\nInspecionando os atributos um objeto\n\nobject.size(x) # Tamanho do objeto\n\n96 bytes\n\nstr(x) # Estrutura do objeto\n\n int [1:10] 1 2 3 4 5 6 7 8 9 10\n\nlength(x) # Comprimento\n\n[1] 10\n\nattributes(x) # Nomes, classes, etc\n\nNULL\n\nclass(x) # Tipo do objeto\n\n[1] \"integer\"\n\nmode(x) # Modo usado pelo R para armazenar objeto na memória\n\n[1] \"numeric\"\n\ntypeof(x) # Tipo usado pelo R para armazenar objeto na memória\n\n[1] \"integer\"\n\n\nInspecione os objetos criados. Exemplos:\n\nclass(x)\n\n[1] \"integer\"\n\nclass(y)\n\n[1] \"character\"\n\nclass(character)\n\n[1] \"character\"\n\nclass(charact_fact)\n\n[1] \"factor\"\n\n\n\n\nTeste e Coerção de objetos\nCom os métodos da função is é possível testar se um objeto corresponde a uma determinada classe. E com os métodos da função as é possível coagir um objeto de uma classe a transformar-se em outra.\nVeja os métodos das funções is e as: (Retire o operador # da frente do comando para rodá-lo)\n\nmethods(is)\n\nWarning in .S3methods(generic.function, class, envir): function 'is' appears\nnot to be S3 generic; found functions that look like S3 methods\n\n\n [1] is.array                is.atomic               is.call                \n [4] is.character            is.complex              is.data.frame          \n [7] is.double               is.element              is.empty.model         \n[10] is.environment          is.expression           is.factor              \n[13] is.finite               is.function             is.hashtab             \n[16] is.infinite             is.integer              is.language            \n[19] is.leaf                 is.list                 is.loaded              \n[22] is.logical              is.matrix               is.mts                 \n[25] is.na                   is.na.data.frame        is.na.numeric_version  \n[28] is.na.POSIXlt           is.na&lt;-                 is.na&lt;-.default        \n[31] is.na&lt;-.factor          is.na&lt;-.numeric_version is.name                \n[34] is.nan                  is.null                 is.numeric             \n[37] is.numeric.Date         is.numeric.difftime     is.numeric.POSIXt      \n[40] is.numeric_version      is.object               is.ordered             \n[43] is.package_version      is.pairlist             is.primitive           \n[46] is.qr                   is.R                    is.raster              \n[49] is.raw                  is.recursive            is.relistable          \n[52] is.single               is.stepfun              is.symbol              \n[55] is.table                is.ts                   is.tskernel            \n[58] is.unsorted             is.vector              \nsee '?methods' for accessing help and source code\n\n# methods(as)\n\nTeste com os objetos já criados:",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "introducao-r.html#rstudio",
    "href": "introducao-r.html#rstudio",
    "title": "Introdução ao R",
    "section": "RStudio",
    "text": "RStudio\nO RStudio é um Ambiente Interativo de Desenvolvimento (IDE) que traz o console R, um editor de script, a exibição dos objetos e funções do ambiente de trabalho, área de plotagem, entre outras funcionalidades e automatizações, dentre as quais:\n\nIdentação automática\nComplementação de parênteses\nEditor com destaque de sintaxe\nAuto-completar comandos",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "introducao-r.html#ambiente-de-trabalho",
    "href": "introducao-r.html#ambiente-de-trabalho",
    "title": "Introdução ao R",
    "section": "Ambiente de Trabalho",
    "text": "Ambiente de Trabalho\n\nO ambiente de trabalho (workspace) é o espaço virtual onde os objetos definidos pelo usuário (vetores, matrizes, dataframes, listas, funções) são alocados.\nNo RStudio, podemos observar o ambiente de trabalho e seus objetos na aba Ènvironment.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "introducao-r.html#diretório-de-trabalho",
    "href": "introducao-r.html#diretório-de-trabalho",
    "title": "Introdução ao R",
    "section": "Diretório de Trabalho",
    "text": "Diretório de Trabalho\n\nO diretório de trabalho (working directory) define o diretório-raiz do caminho de diretórios para fins de entrada e saída de arquivos. Ele define o caminho relativo para um caminho de diretórios.\nO caminho absoluto tem início na pasta raiz do seu disco local do computador. O caminho absoluto do ambiente de trabalho (workspace) pode ser obtido com a função getwd(). Abaixo vemos o diretório-raiz do presente bookdown no computador local:\n\n\ngetwd()\n\n[1] \"D:/gitRepositories/Introducao-a-Filoinformatica\"\n\n\n\n\nls() # lista todos os objetos/funções do Ambiente de Trabalho\n\n[1] \"charact_fact\"    \"character\"       \"função\"          \"pandoc_dir\"     \n[5] \"quarto_bin_path\" \"x\"               \"y\"              \n\nrm(list = ls()) # limpa todo Ambiente de Trabalho\n\nls() # lista todos os objetos/funções do Ambiente de Trabalho\n\ncharacter(0)",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "filogenia-r.html",
    "href": "filogenia-r.html",
    "title": "Filogenia no R",
    "section": "",
    "text": "Pacotes de filogenia",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Filogenia no R</span>"
    ]
  },
  {
    "objectID": "filogenia-r.html#pacotes-de-filogenia",
    "href": "filogenia-r.html#pacotes-de-filogenia",
    "title": "Filogenia no R",
    "section": "",
    "text": "Diversos pacotes para filogenias têm sido desenvolvidos no R. Os pacotes mais importantes são: ape, geiger, ggtree, phangorn, phylobase, phyloch, phytools e treeio.\nO primeiro pacote desenvolvido para filogenia no  foi o ape, lançado em 2002. Nele, a classe phylo, utilizando o sistema S3, foi implementada. Essa classe acabou sendo adotada pela maioria dos pacotes que foram lançados em seguida, e se tornou um padrão.\nPosteriormente, em 2009, a classe phylo4d utilizando o sistema S4 foi implementada no pacote phylobase.\nAtualmente essas são as duas principais classes que armazenam árvores filogenéticas e outros dados associados.\nNão deixe de conferir o site do CRAN, que traz um resumo dos principais pacotes desenvolvidos para análises filogenética: [https://cran.r-project.org/web/views/Phylogenetics.html].",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Filogenia no R</span>"
    ]
  },
  {
    "objectID": "filogenia-r.html#escrevendo-árvores-a-partir-de-uma-cadeia-de-texto",
    "href": "filogenia-r.html#escrevendo-árvores-a-partir-de-uma-cadeia-de-texto",
    "title": "Filogenia no R",
    "section": "Escrevendo árvores a partir de uma cadeia de texto",
    "text": "Escrevendo árvores a partir de uma cadeia de texto\nNotação parentética e o arquivo Newick\n\nFoi adotado em 26 de junho de 1986 numa reunião informal convocada por Joe Felsenstein a membros do comitê durante as reuniões da Sociedade para o Estudo da Evolução em Durham. James Archie, William H E Day Wayne Maddison Christopher Meacham F. James Rohlf e David Swofford.\nA razão do nome é que a segunda e última sessão do comitê se reuniu no restaurante Newick’s Lobster House em Dover, New Hampshire, EUA.\nA representação de árvores foi desenvolvida por Christopher Meacham em 1984 para os programas de plotagem de árvores que ele escreveu para o PHYLIP.\nVamos escrever a árvore a partir de uma cadeia de texto (string):\n\n\nlibrary(ape)\n\nstring.tree &lt;- \"(Taxon1, Taxon2, Taxon3);\"\nstring.tree &lt;- read.tree(text = string.tree)\nplot(string.tree)\n\n\n\n\n\n\n\nstring.tree &lt;- \"((Taxon3, Taxon2), Taxon1);\"\nstring.tree &lt;- read.tree(text = string.tree)\nplot(string.tree)\n\n\n\n\n\n\n\nstring.tree &lt;- \"((Taxon1, Taxon2), Taxon3);\"\nstring.tree &lt;- read.tree(text = string.tree)\nplot(string.tree)\n\n\n\n\n\n\n\n\n\nVamos aprender o passo-a-passo para criar árvores filogenéticas. Para criá-la, comece pelo final da árvore. Vamos usar a árvore filogenética das Monocotiledôneas como exemplo. Observe a construção da árvore passo-a-passo:\n\nEscrevendo árvores através da notação parentética:\n\n“(Zingiberales, Commelinales);” “((Zingiberales, Commelinales), Poales);” “(((Zingiberales, Commelinales), Poales), Arecales);” “((((Zingiberales, Commelinales), Poales), Arecales),(Asparagales, Petrosaviales));” “(((((Zingiberales, Commelinales), Poales), Arecales),(Asparagales, Petrosaviales)), Liliales);” “((((((Zingiberales, Commelinales), Poales), Arecales),(Asparagales, Petrosaviales)), Liliales),(Pandanales, Dioscoriales));” “(((((((Zingiberales, Commelinales), Poales), Arecales),(Asparagales, Petrosaviales)), Liliales),(Pandanales, Dioscoriales)), Alismatales);” “((((((((Zingiberales, Commelinales), Poales), Arecales),(Asparagales, Petrosaviales)),Liliales),(Pandanales, Dioscoriales)), Alismatales), Acorales);” Execute cada bloco no console R, para exibir as topologias, uma de cada vez:\n\n\nMonocots &lt;- \"(Zingiberales, Commelinales);\"\nMonocots &lt;- read.tree(text = Monocots)\nplot(Monocots)\n\n\n\n\n\n\n\nMonocots &lt;- \"((Zingiberales, Commelinales), Poales);\"\nMonocots &lt;- read.tree(text = Monocots)\nplot(Monocots)\n\n\n\n\n\n\n\nMonocots &lt;- \"(((Zingiberales, Commelinales), Poales), Arecales);\"\nMonocots &lt;- read.tree(text = Monocots)\nplot(Monocots)\n\n\n\n\n\n\n\nMonocots &lt;- \"((((Zingiberales, Commelinales), Poales), Arecales),(Asparagales, Petrosaviales));\"\nMonocots &lt;- read.tree(text = Monocots)\nplot(Monocots)\n\n\n\n\n\n\n\nMonocots &lt;- \"(((((Zingiberales, Commelinales), Poales), Arecales),(Asparagales, Petrosaviales)), Liliales);\"\nMonocots &lt;- read.tree(text = Monocots)\nplot(Monocots)\n\n\n\n\n\n\n\nMonocots &lt;- \"((((((Zingiberales, Commelinales), Poales), Arecales),(Asparagales, Petrosaviales)),Liliales),(Pandanales, Dioscoriales));\"\nMonocots &lt;- read.tree(text = Monocots)\nplot(Monocots)\n\n\n\n\n\n\n\nMonocots &lt;- \"(((((((Zingiberales, Commelinales), Poales), Arecales),(Asparagales, Petrosaviales)), Liliales),(Pandanales, Dioscoriales)), Alismatales);\"\nMonocots &lt;- read.tree(text = Monocots)\nplot(Monocots)\n\n\n\n\n\n\n\nMonocots &lt;- \"((((((((Zingiberales, Commelinales), Poales), Arecales),(Asparagales, Petrosaviales)), Liliales),(Pandanales, Dioscoriales)), Alismatales), Acorales);\"\nMonocots &lt;- read.tree(text = Monocots)\nplot(Monocots)\n\n\n\n\n\n\n\n\nImporte também a árvore das Embriófitas:\n\nplants.tree &lt;- \"((((((((((((((Eudicots), Monocots), Magnoliids), Chloranthales), Autrobaileyales), Nymphaeales), Amborellales),((((Gnetales, Conifers), Gingkoales), Cycadales))),(((Sphenophytes, Marattiales), Filicales),(Ophioglossaceae, Psilophytes))),(Selaginellales, Lycopodiales)),(Bryophyta)),(Anthocerophyta)),(Marchantiophyta)));\"\nplants.tree &lt;- read.tree(text = plants.tree)\nplot(plants.tree)\n\n\n\n\n\n\n\n\nInspecione os objetos de classe phylo criados:\n\nstr(Monocots)\n\nList of 3\n $ edge     : int [1:20, 1:2] 12 13 14 15 16 17 18 19 19 18 ...\n $ Nnode    : int 10\n $ tip.label: chr [1:11] \"Zingiberales\" \"Commelinales\" \"Poales\" \"Arecales\" ...\n - attr(*, \"class\")= chr \"phylo\"\n - attr(*, \"order\")= chr \"cladewise\"\n\nstr(plants.tree)\n\nList of 3\n $ edge     : int [1:46, 1:2] 22 23 24 25 26 27 28 29 30 31 ...\n $ Nnode    : int 26\n $ tip.label: chr [1:21] \"Eudicots\" \"Monocots\" \"Magnoliids\" \"Chloranthales\" ...\n - attr(*, \"class\")= chr \"phylo\"\n - attr(*, \"order\")= chr \"cladewise\"\n\nclass(Monocots)\n\n[1] \"phylo\"\n\ntypeof(plants.tree)\n\n[1] \"list\"\n\n\nCheque os componentes dos objetos criados utilizando o operador $:\n\nMonocots$edge\n\n      [,1] [,2]\n [1,]   12   13\n [2,]   13   14\n [3,]   14   15\n [4,]   15   16\n [5,]   16   17\n [6,]   17   18\n [7,]   18   19\n [8,]   19    1\n [9,]   19    2\n[10,]   18    3\n[11,]   17    4\n[12,]   16   20\n[13,]   20    5\n[14,]   20    6\n[15,]   15    7\n[16,]   14   21\n[17,]   21    8\n[18,]   21    9\n[19,]   13   10\n[20,]   12   11\n\nMonocots$tip.label\n\n [1] \"Zingiberales\"  \"Commelinales\"  \"Poales\"        \"Arecales\"     \n [5] \"Asparagales\"   \"Petrosaviales\" \"Liliales\"      \"Pandanales\"   \n [9] \"Dioscoriales\"  \"Alismatales\"   \"Acorales\"     \n\nMonocots$Nnode\n\n[1] 10\n\nplants.tree$edge\n\n      [,1] [,2]\n [1,]   22   23\n [2,]   23   24\n [3,]   24   25\n [4,]   25   26\n [5,]   26   27\n [6,]   27   28\n [7,]   28   29\n [8,]   29   30\n [9,]   30   31\n[10,]   31   32\n[11,]   32   33\n[12,]   33   34\n[13,]   34   35\n[14,]   35    1\n[15,]   34    2\n[16,]   33    3\n[17,]   32    4\n[18,]   31    5\n[19,]   30    6\n[20,]   29    7\n[21,]   28   36\n[22,]   36   37\n[23,]   37   38\n[24,]   38   39\n[25,]   39    8\n[26,]   39    9\n[27,]   38   10\n[28,]   37   11\n[29,]   27   40\n[30,]   40   41\n[31,]   41   42\n[32,]   42   12\n[33,]   42   13\n[34,]   41   14\n[35,]   40   43\n[36,]   43   15\n[37,]   43   16\n[38,]   26   44\n[39,]   44   17\n[40,]   44   18\n[41,]   25   45\n[42,]   45   19\n[43,]   24   46\n[44,]   46   20\n[45,]   23   47\n[46,]   47   21\n\nplants.tree$tip.label\n\n [1] \"Eudicots\"        \"Monocots\"        \"Magnoliids\"      \"Chloranthales\"  \n [5] \"Autrobaileyales\" \"Nymphaeales\"     \"Amborellales\"    \"Gnetales\"       \n [9] \"Conifers\"        \"Gingkoales\"      \"Cycadales\"       \"Sphenophytes\"   \n[13] \"Marattiales\"     \"Filicales\"       \"Ophioglossaceae\" \"Psilophytes\"    \n[17] \"Selaginellales\"  \"Lycopodiales\"    \"Bryophyta\"       \"Anthocerophyta\" \n[21] \"Marchantiophyta\"\n\nplants.tree$Nnode\n\n[1] 26",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Filogenia no R</span>"
    ]
  },
  {
    "objectID": "filogenia-r.html#importando-árvores-nos-formatos-s3-e-s4",
    "href": "filogenia-r.html#importando-árvores-nos-formatos-s3-e-s4",
    "title": "Filogenia no R",
    "section": "Importando árvores nos formatos S3 e S4",
    "text": "Importando árvores nos formatos S3 e S4\n\nClasse phylo (S3)\nImportante saber que árvores importadas como classe S3. Primeiro, apenas uma árvore pode ser armazenada como um objeto classe S3. E apenas a topologia, o comprimento dos ramos e os nomes dos terminais são importados. Lembre-se que para acessar instâncias de objetos S3 é utilizado o operator cifrão “$”.\nUm objeto de classe phylo é uma lista com os seguintes componentes:\n\nEdge a two-column matrix where each row represents a branch (or edge) of the tree; the nodes and the tips are symbolized with integers; the n tips are numbered from 1 to n, and the m (internal) nodes from n+1 to n+m (the root being n + 1).\ntip.label a vector of mode character giving the labels of the tips; the order of these labels corresponds to the integers 1 to n in edge.\nNnode an integer value giving the number of nodes in the tree (m).\nedge.length (opcional) a numeric vector giving the lengths of the branches given by edge.\nnode.label (opcional) a vector of mode character giving the labels of the nodes (ordered in the same way than tip.label).\nroot.edge (optional) a numeric value giving the length of the branch at the root if it exists.\n\n\n\nClasse phylo4 e phylo4d (S4)\nPor outro lado, inúmeras árvores podem ser armazenadas como um objeto de classe S4. Além de guardar as mesmas informações dos objetos S3, também pode armazenar outros dados, tais quais o suporte dos ramos entre outras informações sobre os ramos, e caracteres específicos dos terminais. Para acessar as instâncias de objetos S4 utiliza-se o operator arroba “@”. Ambos os operatores são usados para acessar as instâncias de objetos S4, na ordem @ e $.\nA classe phylo4 armazena apenas árvores, enquanto a classe phylo4d armazena tanto árvores quanto outros dados associados, como um dataframe contendo dados sobbre os ramos e terminais.\n\n\nImportando do IQTree\n\nlibrary(treeio)\nlibrary(phytools)\nlibrary(ggtree)\nlibrary(ggplot2)\n\ntree &lt;- read.iqtree(\"files/trees/example.phy.contree\")\ntree@phylo &lt;- force.ultrametric(tree@phylo)\n\n***************************************************************\n*                          Note:                              *\n*    force.ultrametric does not include a formal method to    *\n*    ultrametricize a tree & should only be used to coerce    *\n*   a phylogeny that fails is.ultramtric due to rounding --   *\n*    not as a substitute for formal rate-smoothing methods.   *\n***************************************************************\n\ntree@data$bootstrap &lt;- as.numeric(tree@phylo$node.label)\ntree.plot &lt;- ggtree(tree, size = 3, aes(color = bootstrap))  +\n  scale_color_continuous(low = \"red\", high = \"blue\") +\n  geom_treescale(fontsize = 10, width = 0.01) +\n  geom_nodelab(aes(x = branch, label = round(bootstrap, 1)), vjust = -0.5, size = 10) +  \n  theme(legend.position= c(0.1, 0.8), legend.key.size = unit(1.5, \"cm\")) +\n  theme(legend.text = element_text(size  = 10)) +\n  theme(legend.title = element_text(size = 10)) +\n  geom_tiplab(size = 10, color = \"black\", hjust = 1)\n\ntree.plot\n\n\n\n\n\n\n\n\n\n\nImportando do MrBayes\n\nlibrary(treeio)\n\nfile &lt;- system.file(\"extdata/MrBayes\", \"Gq_nxs.tre\", package=\"treeio\")\ntree.mrbayes &lt;- read.mrbayes(file)\nplot(tree.mrbayes@phylo)",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Filogenia no R</span>"
    ]
  },
  {
    "objectID": "filogenia-r.html#extraindo-clados",
    "href": "filogenia-r.html#extraindo-clados",
    "title": "Filogenia no R",
    "section": "Extraindo clados",
    "text": "Extraindo clados\nA função extract.clade() obtém uma árvore a partir de um determinado nó.\n\nVamos plotar a árvore das plantas:\n\n\nlibrary(ape)\n\nplants.tree &lt;- \"((((((((((((((Eudicots), Monocots), Magnoliids), Chloranthales), Autrobaileyales), Nymphaeales), Amborellales),((((Gnetales, Conifers), Gingkoales), Cycadales))),(((Sphenophytes, Marattiales), Filicales),(Ophioglossaceae, Psilophytes))),(Selaginellales, Lycopodiales)),(Bryophyta)),(Anthocerophyta)),(Marchantiophyta)));\"\n\nplants.tree &lt;- read.tree(text = plants.tree)\n\nplot(plants.tree)\n\n\n\n\n\n\n\n\n\nOs nomes dos terminais (tip labels) são numerados em ordem consecutiva começando do 1:\n\n\nplot(plants.tree)\ntiplabels()\n\n\n\n\n\n\n\n\n\nOs nós (nodes) são numerados em ordem consecutiva começando do número consecutivo ao número de terminais:\n\n\nlength(plants.tree$tip.label) + 1\n\n[1] 22\n\n\n\nVejam os rótulos (labels) dos nós:\n\n\nplot(plants.tree)\nnodelabels()\n\n\n\n\n\n\n\n\n\nVamos extrair os clados com base no número (rótulo) do nó:\n\n\ntree1 &lt;- extract.clade(phy = plants.tree, node = 29)\nplot(tree1)\n\n\n\n\n\n\n\n# Tente a seleção do nó interativamente\n# tree2 &lt;- extract.clade(plants.tree, interactive = T)\n# plot(tree2)\n\n\nAgora vamos importar a árvore do APG:\n\nImporte a árvore:\n\n\nlibrary(ape)\n\napg.tree &lt;- read.tree(\"./files/trees/apg.tree\")\n\n\nVamos extrair o clado das Lamiales:\n\n\ntree &lt;- extract.clade(phy = apg.tree, node = \"lamiales\")\nplot(tree)\nnodelabels(tree$node.label, frame = \"none\", cex = 0.7)\n\n\n\n\n\n\n\n\n\nVamos descobrir como localizar certa string no conjunto de rótulos dos nós.\n\nVamos procurar o: Clado das Fixadoras de Nitrogênio (clado CFN) FABA-ROSA-CUCU-FAGA\n\n\n\nnome &lt;- \"nitrogen\"\nindex_of_clades_found &lt;- grep(nome, apg.tree$node.label)\napg.tree$node.label[index_of_clades_found]\n\n[1] \"nitrogenfixing_to_COM\" \"nitrogenfixing\"       \n\n\n\nExtraia o clado:\n\n\ntree &lt;- extract.clade(phy = apg.tree, node = \"nitrogenfixing\")\nplot(tree)\nnodelabels(tree$node.label, frame = \"none\", cex = 0.7)",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Filogenia no R</span>"
    ]
  },
  {
    "objectID": "filogenia-r.html#personalizando-o-estilo-da-árvore",
    "href": "filogenia-r.html#personalizando-o-estilo-da-árvore",
    "title": "Filogenia no R",
    "section": "Personalizando o estilo da árvore",
    "text": "Personalizando o estilo da árvore\nAgora que temos um conjunto de objetos de classe phylo e phylo4, vamos aprender a alterar o design das árvores utilizando alguns dos principais pacotes para filogenia. Vamos conhecer um pacote de cada vez.\n\nPacote ape\nO pacote ape\n\nManual\n\nPerceba que o pacote ape implementou um método para a função plot() do pacote graphics, o plot.phylo(). Então, desde que o objeto seja de classe phylo ou phylo4 (ou ainda phylo4d) não se faz necessário digitar “.phylo” depois de plot:\n\nplot(plants.tree, type = \"phylogram\") # Default\n\n\n\n\n\n\n\nplot(plants.tree, type = \"cladogram\")\n\n\n\n\n\n\n\nplot(plants.tree, type = \"fan\")\n\n\n\n\n\n\n\nplot(plants.tree, type = \"radial\")\n\n\n\n\n\n\n\n\nPara gerar uma árvore não-enraizada, utilize a função unroot() para retirar a raiz da árvore, e use o argumento type = “unrooted” e lab4ut = “axial” da função plot.phylo():\n\nplot(unroot(plants.tree), type = \"unrooted\", lab4ut = \"axial\")\n\n\n\n\n\n\n\n\nAltere a direção da árvore com argumento direction:\n\nplot(Monocots, direction = \"leftwards\")\n\n\n\n\n\n\n\nplot(Monocots, direction = \"upwards\")\n\n\n\n\n\n\n\nplot(Monocots, direction = \"downwards\")\n\n\n\n\n\n\n\n\nGire o ângulo da árvore com o argumento rotate.tree:\n\nplot(Monocots, type = \"fan\")\n\n\n\n\n\n\n\nplot(Monocots, type = \"fan\", rotate.tree = 50)\n\n\n\n\n\n\n\n\nAbra o ângulo da árvore com argumento open.angle:\n\nplot(plants.tree, type = \"fan\")\n\n\n\n\n\n\n\nplot(plants.tree, type = \"fan\", open.angle = 180)\n\n\n\n\n\n\n\n\nAltere a direção os nomes dos terminais (tip.label) com o argumento lab4ut como “horizontal”:\n\nplot(Monocots, type = \"fan\", lab4ut=\"horizontal\")\n\n\n\n\n\n\n\n\nAltere o tamanho da árvore com os argumentos x.lim e y.lim:\n\nplot(plants.tree, x.lim = 25, y.lim = 22)\n\n\n\n\n\n\n\nplot(plants.tree, x.lim = 100, y.lim = 22)\n\n\n\n\n\n\n\nplot(plants.tree, x.lim = 150, y.lim = 22)\n\n\n\n\n\n\n\nplot(plants.tree, x.lim = 200, y.lim = 30)\n\n\n\n\n\n\n\nplot(plants.tree, x.lim = 250, y.lim = 30)\n\n\n\n\n\n\n\n\nPara executar diversas alterações, mudanças de estilos e anotações na árvore, é preciso saber qual o número associado a cada ramo e aos terminais. Para descobrir esses números usaremos as funções edgelabels(), tiplabels e nodelabels():\n\nplot(Monocots)\nedgelabels()\ntiplabels()\n\n\n\n\n\n\n\nplot(Monocots)\nnodelabels()\n\n\n\n\n\n\n\n\n\nRamos\nAltere a espessura dos ramos da árvore com o argumento edge.width: (default: 1)\n\nplot(plants.tree, edge.width = 3)\n\n\n\n\n\n\n\n\nAltere o formato da linha correspondente aos ramos com o argumento edge.lty (de 1 a 6): (Default: 1)\n\nplot(plants.tree, edge.lty = 2)\n\n\n\n\n\n\n\n\nAltere a cor dos ramos da árvore com argumento edge.color: (Default: 1)\n\nplot(plants.tree, edge.color = \"blue\")\n\n\n\n\n\n\n\nplot(plants.tree, edge.color = c(\"blue\", \"red\"))\n\n\n\n\n\n\n\nplot(plants.tree, edge.color = c(\"blue\", \"red\", \"yellow\"))\n\n\n\n\n\n\n\nplot(plants.tree, edge.color = 0) # 0 = sem cor\n\n\n\n\n\n\n\nplot(plants.tree, edge.color = 5)\n\n\n\n\n\n\n\n\nAltere a cor dos ramos selecionados da árvore com função def. A função def gera um vetor com os nomes dos terminais (tip.label):\n\nplot(plants.tree)\nnodelabels()\n\n\n\n\n\n\n\ndef1 &lt;- def(plants.tree$edge, `30` = \"blue\", `31` = \"blue\", `32` = \"blue\", `33` = \"blue\",\n    `34` = \"blue\", `35` = \"blue\")\nplot(plants.tree, edge.color = def1)\n\n\n\n\n\n\n\n\nA função def() pode ser utilizada com qualquer outro argumento da função plot.phylo(), mas teremos de indicar o estado de cada um dos nós nodelabels). Vamos repetir o código acima, no qual usamos a função def(), mas vamos incluir mais uma definição, a da espessura dos ramos. Perceba que ao criar o objeto def2 associamos a todos os números do nodelabels o número “1”, exceto os números 38, 39 e 40 que estão associados ao “3”:\n\nplot(plants.tree)\nnodelabels()\n\n\n\n\n\n\n\ndef2 &lt;- def(plants.tree$edge, `1` = 1, `2` = 1, `3` = 1, `4` = 1, `5` = 1, `6` = 1,\n    `7` = 1, `8` = 1, `9` = 1, `10` = 1, `11` = 1, `12` = 1, `13` = 1, `14` = 1,\n    `15` = 1, `16` = 1, `17` = 1, `18` = 1, `19` = 1, `20` = 1, `21` = 1, `22` = 1,\n    `23` = 1, `24` = 1, `25` = 1, `26` = 1, `27` = 1, `28` = 1, `29` = 1, `30` = 1,\n    `31` = 1, `32` = 1, `33` = 1, `34` = 1, `35` = 1, `36` = 1, `37` = 1, `38` = 3,\n    `39` = 3, `40` = 3, `41` = 1, `42` = 1, `43` = 1, `44` = 1, `45` = 1, `46` = 1,\n    `47` = 1, `47` = 1, `48` = 1, `49` = 1)\nplot(plants.tree, edge.width = def2, edge.lty = def2)\n\n\n\n\n\n\n\n\nAltere a cor dos ramos, ou outro parâmetro, com função rep() do pacote base:\n\nplot(plants.tree)\nedgelabels()\n\n\n\n\n\n\n\ncol &lt;- c(\"blue\", rep(\"red\", 2), rep(\"green\", 2), \"brown\", rep(\"black\", 14), rep(\"brown\",\n    8), rep(\"green\", 12), rep(\"red\", 6), \"blue\")\nplot(plants.tree, edge.color = col, edge.width = 4)\n\n\n\n\n\n\n\n\nPlote diferentes tipos de símbolos nos ramos da árvore com a função edgelabels(). Escolha o tipo de símbolo com o argumento pch, equivalente à função points do pacote graphics (veja essa função para descobrir os códigos dos símbolos, valores vão de 0 a 25). O argumento col altera a cor do símbolo. O argumento cex define o tamanho do símbolo (Default: 0). O argumento adj funciona como um eixo x e y para posição do símbolo:\n\nplot(plants.tree)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 0)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = -0.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 0.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = -1)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 1)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = -1.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 1.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 2)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 2.5)\n\n\n\n\n\n\n\n\n\n\nTerminais\nAumente a distância entre os nomes dos terminais (tip.label) e a árvore com o argumento label.offset: (experimente também outros valores diferentes de 1. (Default: 0)\n\nplot(Monocots, label.offset = 1)\n\n\n\n\n\n\n\n\nAltere a fonte dos terminais com argumento font (1: sem formato, 2: negrito, 3: italic, 4: negrito e itálico, etc): (Default: 3)\n\nplot(Monocots, font = 4)\n\n\n\n\n\n\n\n\nAltere o tamanho da fonte dos terminais com argumento cex: (Default: 1)\n\nplot(Monocots, cex = 0.5)\n\n\n\n\n\n\n\n\nAltere a justificação dos nomes dos terminais com argumento adj (de 0 a 1): (Default: 0)\n\nplot(Monocots, adj = 0.5)\n\n\n\n\n\n\n\nplot(Monocots, adj = 1)\n\n\n\n\n\n\n\n\nAltere a inclinação dos nomes dos terminais com argumento srt: (Default: 0)\n\nplot(plants.tree, srt = 25)\n\n\n\n\n\n\n\n\nAltere a cor da fonte do terminais com argumento tip.color: (Default: 1)\n\nplot(Monocots, tip.color = \"red\")\n\n\n\n\n\n\n\nplot(Monocots, tip.color = 0) # 0 = branco\n\n\n\n\n\n\n\nplot(Monocots, tip.color = 4)\n\n\n\n\n\n\n\n\nVamos usar a função def() para especificar as cores dos nomes dos terminais, e também, vamos alterar a fonte:\n\ndef3 &lt;- def(plants.tree$tip.label, Gnetales = \"blue\", Filicales = \"red\")\nplot(plants.tree, tip.color = def3)\n\n\n\n\n\n\n\ndef4 &lt;- def(plants.tree$tip.label, Gnetales = 2, Filicales = 4)\nplot(plants.tree, font = def4)\n\n\n\n\n\n\n\n\nVamos alterar a cor dos terminais usando função rep():\n\nplot(plants.tree)\ntiplabels()\n\n\n\n\n\n\n\nplot(plants.tree, tip.color = c(rep(\"red\", 7), rep(\"blue\", 4), rep(\"brown\", 5), rep(\"green\",\n    2), rep(\"black\", 3), \"yellow\"))\n\n\n\n\n\n\n\n\nInclua os nomes (tiplabels) apenas para determinados terminais:\n\nPrimeiro, selecione os números dos terminais:\n\n\nplot(plants.tree)\ntiplabels()\n\n\n\n\n\n\n\ni &lt;- c(4, 10, 17)\n\n\nDepois, vamos plotar a árvore sem os nomes dos terminais (show.tip.label = FALSE), introduzir um recuo com o argumento x.lim, e plotar os nomes dos terminais com a função tiplabels():\n\n\nplot(plants.tree, show.tip.label = FALSE, x.lim = 30)\ntiplabels(plants.tree$tip.label[i], i, adj = 0)\n\n\n\n\n\n\n\n\nRetire o quadro em volta do nome com o argumento frame = “none”:\n\nplot(plants.tree, show.tip.label = FALSE, x.lim = 30)\ntiplabels(plants.tree$tip.label[i], i, adj = 0, frame = \"none\")\n\n\n\n\n\n\n\n\nPlote diferentes tipos de símbolos terminais com a função tiplabels(). Com o argumento label.offset, afaste um pouco os nomes dos terminais da árvore:\n\nplot(plants.tree, label.offset = 1)\ntiplabels(tip = 1, pch = 20)\ntiplabels(tip = 2, pch = 19)\ntiplabels(tip = 3, pch = 18)\ntiplabels(tip = 4, pch = 17)\ntiplabels(tip = 5, pch = 16)\ntiplabels(tip = c(6,7), pch = c(15,14))\n\n\n\n\n\n\n\n\nUse também os argumentos cex, para aumentar ou diminuir o tamanho do símbolo, e adj, para afastar o símbolo na horizontal, da função tiplabels(); também altere a cor do fundo do símbolo com o argumento bg:\n\nplot(plants.tree, label.offset = 2.5)\ntiplabels(pch = 19, col = c(\"yellow\", \"red\", \"blue\"), adj = 1.4, cex = 1.5)\ntiplabels(pch = 21, bg = c(\"purple\",\"pink\",\"brown\"), adj = 2.4, cex = 1.5)\n\n\n\n\n\n\n\n\nPlote um símbolo nos terminais interativamente na área de plotagem: (Não esqueça de retirar o símbolo # da frente de cada linha)\n\n# f &lt;- function(col) {\n# o &lt;- identify(plants.tree)\n# tiplabels(tip=o$tips, pch = 19, col = col)\n# }\n# f(\"red\") # Clique no terminal para adicionar o símbolo\n# f(\"green\") # Faça o mesmo\n\n\n\nNós\nPlote os números associados aos nós com a função nodelabels():\n\nplot(plants.tree)\nnodelabels()\n\n\n\n\n\n\n\n\nEnraizar uma árvore com função root():\n\nplot(root(plants.tree, 4)) # Enraizando o nó número 4.\n\nWarning in min(x): no non-missing arguments to min; returning Inf\n\n\nWarning in max(x): no non-missing arguments to max; returning -Inf\n\n\n\n\n\n\n\n\n\nRotacionar uma árvore com função rotate():\n\nplot(plants.tree)\n\n\n\n\n\n\n\nplot(ape::rotate(plants.tree, 25))\n\n\n\n\n\n\n\n# OBS: O comando 'ape::rotate' é um chamamento específico da função rotate do\n# pacote ape. Portanto, os operadores '::' vindos após o nome de um pacote,\n# define a exata função do pacote. Isso é especialmente útil para não precisar\n# carregar o pacote inteiro ou quando existe duplicidade de nome de funções\n# entre pacotes distintos.\n\nPlote diferentes símbolos nos nós:\n\nplot(Monocots)\nnodelabels(pch = 20)\n\n\n\n\n\n\n\n\nPlote diferentes símbolos nos nós determinados:\n\nplot(plants.tree)\nnodelabels(node = 27, pch = 19)\nnodelabels(node = 28, pch = 20)\nnodelabels(node = 29, pch = 21)\n\n\n\n\n\n\n\n\nPlote um símbolo nos nós interativamente: (Retire os símbolos de # para rodar as linhas de comando)\n\n# f2 &lt;- function(col) {\n# o &lt;- identify(Monocots)\n# tiplabels(node=o$nodes, pch = 19, col = col)\n# }\n# f2(\"yellow\") # Clique no terminal para adicionar o símbolo\n# f2(\"blue\") # Faça o mesmo\n\n\n\n\nPacote phylocanvas\n\nlibrary(phylocanvas)\n\ntree &lt;- read.tree(text = \"(A:2, B:2, (C:1, D:1) E:1) F;\")\nphylocanvas(tree)\n\n\n\n\n\n\n\nPacote phytools\nO pacote phytools foi desenvolvido por Liam J. Revell.\n\n\nBlog oficial\nManual\n\nCarregue o pacote:\n\nlibrary(phytools)\n\nPlote a árvore com a função plotTree():\n\nplotTree(plants.tree)\n\n\n\n\n\n\n\n\nAltere o tipo de árvore com o argumento type (phylogram [Default]; fan; cladogram); o tamanho da fonte com o argumento fsize; e o estilo da fonte com ftype (reg = regular [default]; i = itálico; b = negrito; bi = itálico e negrito):\n\nplotTree(plants.tree, type = \"fan\", fsize = 1, ftype = \"i\", offset=1)\n\n\n\n\n\n\n\n\nPlote uma árvore com as bordas arredondadas com a função roundPhylogram:\n\nroundPhylogram(plants.tree)\n\n\n\n\n\n\n\n\nAplicar organização em escada nos clados com a função ladderize():\n\nplot(ladderize(plants.tree))\n\n\n\n\n\n\n\nplot(ladderize(plants.tree, FALSE))\n\n\n\n\n\n\n\n\nRotacione determinados nós com a função rotateNodes():\n\nrt.15 &lt;- rotateNodes(Monocots, 15)\nplotTree(rt.15, node.numbers = T)\n\n\n\n\n\n\n\n\nRotacionando toda a árvore:\n\nrt.all &lt;- rotateNodes(Monocots, \"all\")\nplotTree(rt.all, node.numbers = T)\n\n\n\n\n\n\n\n\nEnraize a árvore a partir de um determinado nó:\n\nrr.13 &lt;- root(Monocots, node = 13)\nplotTree(rr.13, node.numbers = T)\n\n\n\n\n\n\n\nrr.14 &lt;- root(Monocots, node = 14)\nplotTree(rr.14, node.numbers = T)\n\n\n\n\n\n\n\n\nEnraize a árvore interativamente: (Retire os operadores # da frente dos comandos)\n\n# rr.interactive &lt;- reroot(tree, interactive = TRUE)\n# plotTree(rr.interactive, node.numbers = T)\n\nCompare a topologia das árvores com a função all.equal():\n\n# A árvore rotacionada é igual à original?\nall.equal(Monocots, rt.all)\n\n[1] TRUE\n\n# A árvore reenraizada é igual à original?\nall.equal(Monocots, rr.13)\n\n[1] FALSE\n\n# As árvores original e reenraizada tornadas não-enraizadas são iguais:\nall.equal(unroot(Monocots), unroot(rr.13))\n\n[1] TRUE\n\n\nCorte uma árvore ao meio, plotando-a em duas colunas, com função splitplotTree. A função rcoal gera árvores aleatórias com número determinado de terminais:\n\ntrees &lt;- rcoal(50)\nsplitplotTree(trees)\n\n\n\n\n\n\n\n\n\nRamos\nAltere a espessura dos ramos com o argumento lwd:\n\nplotTree(Monocots, lwd = 3)\n\n\n\n\n\n\n\n\n\n\nTerminais\nPlote a árvore sem os terminais:\n\nplotTree(plants.tree, ftype = \"off\")\n\n\n\n\n\n\n\n\nAfaste os nomes dos terminais da árvore com o argumento offset:\n\nplotTree(plants.tree, offset = 1)\n\n\n\n\n\n\n\n\nDescobra o número dos terminais:\n\nspecies &lt;- c(\"Magnoliids\", \"Gingkoales\")\nts &lt;- sapply(species, grep, plants.tree$tip.label)\nts\n\nMagnoliids Gingkoales \n         3         10 \n\nplants.tree$tip.label[ts]\n\n[1] \"Magnoliids\" \"Gingkoales\"\n\n\nAdicione uma seta em determinados terminais:\n\nplotTree(plants.tree, type = \"fan\", offset=1)\nadd.arrow(plants.tree, tip = ts, arrl = 0.3, hedl = 0.1)\n\n\n\n\n\n\n\n\nRetire terminais determinados terminais:\n\ndrop.species &lt;- drop.tip(plants.tree, species)\nplotTree(drop.species, type = \"fan\", ftype = \"i\", offset=1)\n\n\n\n\n\n\n\n\n\n\n\nPacote ggtree\nO pacote ggtree\n\nManual\n\nCarregue os pacotes:\n\nlibrary(ggtree)\nlibrary(ggplot2)\n\nPlote a árvore com a função ggtree():\n\nggtree(plants.tree)\n\n\n\n\n\n\n\n\nEscolha o tipo de árvore com o argumento layout: (Default: “rectangular)\n\nggtree(plants.tree, layout = \"rectangular\")\n\n\n\n\n\n\n\nggtree(plants.tree, layout = \"slanted\") \n\n\n\n\n\n\n\nggtree(plants.tree, layout = \"circular\")\n\n\n\n\n\n\n\nggtree(plants.tree, layout = \"radial\")\n\n\n\n\n\n\n\nggtree(plants.tree, layout = \"equal_angle\")\n\n\n\n\n\n\n\nggtree(plants.tree, layout = \"daylight\")\n\nAverage angle change [1] 0.0706831962525389\n\n\nAverage angle change [2] 0.0231394088195458\n\n\n\n\n\n\n\n\nggtree(plants.tree, layout = \"fan\", open.angle = 120)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\n\n\nGire a árvore do tipo circular com a função rotate_tree():\n\nggtree(plants.tree, layout = 'circular')\n\n\n\n\n\n\n\nrotate_tree(ggtree(plants.tree, layout = 'circular'), 60)\n\nCoordinate system already present. Adding new coordinate system, which will\nreplace the existing one.\n\n\n\n\n\n\n\n\n\nAplicar a ordenação em escada (ladderize):\n\nggtree(plants.tree, ladderize = FALSE)\n\n\n\n\n\n\n\nggtree(plants.tree, ladderize = TRUE)\n\n\n\n\n\n\n\n\nAltere a cor do fundo com função theme_tree(). O operador + adiciona diferentes funções na mesma plotagem:\n\nggtree(plants.tree) + theme_tree()\n\n\n\n\n\n\n\nggtree(plants.tree) + theme_tree(bgcolor = \"gray\")\n\n\n\n\n\n\n\nggtree(plants.tree) + theme_tree(bgcolor = \"lightblue\")\n\n\n\n\n\n\n\n\nAltere a direção da árvore com as funções scale_x_reverse() e coord_flip() do pacote ggplot2:\n\nggtree(plants.tree) + scale_x_reverse()\n\n\n\n\n\n\n\nggtree(plants.tree) + coord_flip()\n\n\n\n\n\n\n\nggtree(plants.tree) + scale_x_reverse() + coord_flip()\n\n\n\n\n\n\n\n\nDefina o tamanho da árvore com a função coord_cartesian do pacote ggplot:\n\nggtree(plants.tree) + coord_cartesian(xlim = c(0, 50), ylim = c(0, 22))\n\n\n\n\n\n\n\n\nDefina o limite do eixo x com função xlim():\n\nggtree(plants.tree, layout='circular') + xlim(-20, 15)\n\n\n\n\n\n\n\n\nAdicionando escala com a função geom_treescale():\n\nggtree(plants.tree) + geom_treescale()\n\n\n\n\n\n\n\n\nAltere os parâmetros da escala com argumentos específicos:\n\nggtree(plants.tree) + geom_treescale(x = 1, y = 20, width = 1, color = 'red', fontsize = 4, linesize = 2, offset = 1)\n\n\n\n\n\n\n\n\n\nRamos\nColoque textos nos ramos:\n\nggtree(plants.tree) +\n  geom_text2(aes(x = branch, label = \"Eba!\"))\n\n\n\n\n\n\n\n\nAltere a cor da linha da árvore:\n\nggtree(plants.tree, color = \"firebrick\")\n\n\n\n\n\n\n\n\nAltere o tipo de linha da árvore: (Default: “solid”)\n\nggtree(plants.tree, lty = \"solid\")\n\n\n\n\n\n\n\nggtree(plants.tree, lty = \"dotted\")\n\n\n\n\n\n\n\nggtree(plants.tree, lty = \"dashed\")\n\n\n\n\n\n\n\nggtree(plants.tree, lty = \"dotdash\")\n\n\n\n\n\n\n\nggtree(plants.tree, lty = \"longdash\")\n\n\n\n\n\n\n\nggtree(plants.tree, lty = \"twodash\")\n\n\n\n\n\n\n\nggtree(plants.tree, lty = \"F1\")\n\n\n\n\n\n\n\n\nAltere a espessura da linha da árvore: (Default: 0)\n\nggtree(plants.tree, size = 2)\n\n\n\n\n\n\n\n\nAltere parâmetros estéticos dos ramos de acordo com os clados com a função groupClade():\n\nPrimeiro visualize os números dos nós:\n\n\nggtree(Monocots) + geom_text2(aes(subset=!isTip, label=node), hjust=-.3)\n\n\n\n\n\n\n\n\n\nSelecione o clado que terá suas configurações alteradas:\n\n\ngroup &lt;- groupClade(Monocots, .node=16)\n\n\nAltere a cor com o argumento color da função aes():\n\n\nggtree(group, aes(color=group))\n\n\n\n\n\n\n\n\n\nDefina a cor dos grupos com a função scale_color_manual() do pacote ggplot2:\n\n\nggtree(group, aes(color = group)) + scale_color_manual(values = c(\"black\", \"firebrick\"))\n\n\n\n\n\n\n\n\n\nAltere o tipo de linha com o argumento linetype da função aes():\n\n\nggtree(group, aes(linetype=group))\n\n\n\n\n\n\n\n\n\nDefina o tipo de linha com a função scale_linetype_manual() do pacote ggplot2:\n\n\nggtree(group, aes(linetype = group)) + scale_linetype_manual(values = c(3, 2))\n\n\n\n\n\n\n\n\n\nAltere a espessura da linha com o argumento size da função aes():\n\n\nggtree(group, aes(size = group))\n\nWarning: Using size for a discrete variable is not advised.\n\n\n\n\n\n\n\n\n\n\nDefina o tamanho da linha com a função scale_size_manual() do pacote ggplot2:\n\n\nggtree(group, aes(size = group)) + scale_size_manual(values = c(1, 1.5))\n\n\n\n\n\n\n\n\n\nAltere e defina a transparência da linha com o argumento alpha da função aes():\n\n\nggtree(group, aes(alpha=group)) + scale_alpha_manual(values = c(1/2,1/5))\n\n\n\n\n\n\n\n\n\nUtilize quantos clados forem necessários:\n\n\ngroup2 &lt;- groupClade(Monocots, .node = c(17, 20, 21))\nggtree(group2, aes(color = group, linetype = group, size = group))\n\n\n\n\n\n\n\n\nAdicione uma escala de cores contínuas com função scale_color_continuous() do pacote ggplot2:\n\n# ggtree(tree, aes(color = posterior)) + \n#  scale_color_continuous(low = \"green\", high = \"red\") +\n#  theme(legend.position = \"bottom\")\n\nAdicione barras com a maior densidade posterior (HPD) nos nós, usando um vetor do tipo ‘double’ (valor min-máx), com a função geom_range():\n\n# ggtree(beast_tree) + geom_tiplab() + geom_range(\"length_0.95_HPD\", color = 'red', size = 2, alpha = .5)\n\n\n\nTerminais\nAdicione os nomes dos terminais com a função geom_tiplab():\n\nggtree(plants.tree) + geom_tiplab() + coord_cartesian(xlim = c(0, 50), ylim = c(0, 22))\n\n\n\n\n\n\n\n\nAdicione os nomes dos terminais apenas para um dos clados marcados no objeto group criado na seção a cima:\n\nggtree(group) + geom_tiplab(aes(subset = (group == 1)))\n\n\n\n\n\n\n\nggtree(group) + geom_tiplab(aes(subset = (group == 0)))\n\n\n\n\n\n\n\n\nAdicione determinados nomes dos terminais:\n\nggtree(plants.tree) + geom_tiplab(aes(subset = (node %in% c(1, 2, 3, 4))))\n\n\n\n\n\n\n\nggtree(Monocots) + geom_tiplab(aes(subset = (node %in% c(1, 2, 3, 4))), color = c(\"blue\", \"red\", \"green\", \"pink\"))\n\n\n\n\n\n\n\n\nCrie grupos de terminais utilizando vetores com nomes dos terminais ou números com função groupOTU():\n\ngroupOTU(ggtree(plants.tree), c(\"Monocots\", \"Eudicots\")) + aes(color = group) + geom_tiplab()\n\n\n\n\n\n\n\ngroupOTU(ggtree(plants.tree), 1:5) + aes(color = group) + geom_tiplab()\n\n\n\n\n\n\n\ngroupOTU(ggtree(plants.tree), c(1:5,10)) + aes(color = group) + geom_tiplab()\n\n\n\n\n\n\n\n\nAltere alguns parâmetros estéticos dos nomes dos terminais com argumentos específicos:\n\nggtree(plants.tree) + geom_tiplab(offset = 0.5, col = \"blue\", size = 1.8) + coord_cartesian(xlim = c(0, 50), ylim = c(0, 22))\n\n\n\n\n\n\n\n\nAdicione os nomes dos terminais em árvores do tipo circular com função geom_tiplab2(), e veja a diferença entre a função geom_tiplab():\n\nggtree(plants.tree, layout = \"circular\") + geom_tiplab(offset = 0.5, size = 1.8)\n\n\n\n\n\n\n\nggtree(plants.tree, layout = \"circular\") + geom_tiplab2(offset = 0.5, size = 1.8)\n\n\n\n\n\n\n\n\nAdicione símbolos nos terminais com função geom_tippoint():\n\nggtree(plants.tree) + geom_tippoint()\n\n\n\n\n\n\n\n\nAltere o tipo do símbolo nos terminais com o argumento shape. A coloração dos símbolos com fundo colorido é definida com o argumento fill:\n\nggtree(plants.tree) + geom_tippoint(shape = 22, fill=\"red\")\n\n\n\n\n\n\n\n\nAdicione símbolos em um determinado terminal:\n\nggtree(Monocots) + geom_tippoint(aes(subset = node == 5))\n\n\n\n\n\n\n\n\nAdicionando nomes dos clados com função geom_cladelabel():\n\nggtree(Monocots) + geom_cladelabel(node = 17, label = \"Clade A\") + geom_cladelabel(node = 20, label = \"Clade B\") + coord_cartesian(xlim = c(0, 10), ylim = c(0, 12))\n\nWarning: The following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\n\n\n\n\n\n\n\n\n\nAltere parâmetros estéticos com argumentos específicos:\n\nggtree(Monocots) + geom_cladelabel(node = 17, label = \"Clade A\", align = T, color = 'red', angle = 45) + geom_cladelabel(node = 20, label = \"Clade B\", align = T, color = 'blue', angle = 45) + coord_cartesian(xlim = c(0, 10), ylim = c(0, 12))\n\nWarning: The following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\n\n\n\n\n\n\n\n\n\nColoque uma caixa em volta do nome do clado com argumento geom():\n\nggtree(Monocots) + geom_cladelabel(node = 17, label = \"Clade A\", geom = 'label', fill = 'lightblue') + geom_cladelabel(node = 20, label = \"Clade B\", geom = 'label', fill = 'lightgreen') + coord_cartesian(xlim = c(0, 10), ylim = c(0, 12))\n\nWarning: The following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation: node\nand parent.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\n\n\n\n\n\n\n\n\n\nAdicione uma barra com função geom_strip():\n\nggtree(Monocots) + geom_strip(2, 4, barsize = 2, color = 'red') + geom_strip(8, 6, barsize = 2, color = 'blue')\n\n\n\n\n\n\n\n\nDestaque clados com função geom_hilight():\n\ntree4 &lt;- pbtree(n = 50, scale = 100)\nggtree(tree4, layout=\"circular\") + geom_hilight(node = 72, fill = \"steelblue\", alpha = .6) + geom_hilight(node = 91, fill = \"darkgreen\", alpha = .6)\n\n\n\n\n\n\n\n\nDestaque clados com função geom_hilight_encircle():\n\n#ggtree(tree4, layout = \"circular\") + geom_hilight_encircle(node = 72) + geom_hilight_encircle(node = 91, fill = 'darkgreen')\n\nDestaque os clados com highlight interativamente: (Retire os operadores # da frente dos comandos)\n\n# p &lt;- ggtree(tree4)\n# cols &lt;- rainbow(5)\n# ggtree(tree)\n# for (i in 1:5) {\n#  p &lt;- p + geom_hilight(identify(p), fill=cols[i])\n#  print(p)\n# }\n\n\n\nNós\nAdicione os números dos nós com a função geom_text2():\n\nggtree(Monocots) + geom_text2(aes(subset = !isTip, label = node))\n\n\n\n\n\n\n\n\nAjuste a posição do dos números dos nós com os argumentos hjust e vjust:\n\nggtree(Monocots) + geom_text2(aes(subset = !isTip, label = node), hjust = 1.1, vjust = -.2)\n\n\n\n\n\n\n\n\nAdicione símbolos aos nós com função geom_nodepoint():\n\nggtree(Monocots) + geom_nodepoint()\n\n\n\n\n\n\n\n\nAdicione um símbolo em um determinado nó:\n\nggtree(Monocots) + geom_nodepoint(aes(subset = (node == 16)))\n\n\n\n\n\n\n\nggtree(Monocots) + geom_nodepoint(aes(subset = (node == c(16, 21))))\n\n\n\n\n\n\n\n\nAltere os parâmetros estéticos com argumentos específicos. O argumento alpha altera a transparência do símbolo:\n\nggtree(Monocots) + geom_nodepoint(color = \"#b5e521\", alpha = 1/4, size = 10)\n\n\n\n\n\n\n\n\nAdicione símbolos aos nós por clados com a já mencionada função groupClade():\nAdicione símbolos aos nós com função geom_point2(): (OBS: os símbolos também são adicionados nos terminais)\n\nggtree(Monocots) + geom_point2()\n\n\n\n\n\n\n\n\nRotacione todos os nós a partir de um dado nó com função rotate e a função pipe %&gt;%:\n\nggtree(Monocots) + geom_text2(aes(subset = !isTip, label = node)) + geom_tiplab()\n\n\n\n\n\n\n\nggtree(Monocots) %&gt;% ggtree::rotate(16) + geom_text2(aes(subset = !isTip, label = node)) + geom_tiplab()\n\n\n\n\n\n\n\n\nRotacione interativamente os nós: (Retire o operador # da frente dos comandos)\n\n# p &lt;- ggtree(plants.tree) + geom_tiplab() + coord_cartesian(xlim = c(0, 50), ylim = c(0, 22))\n# for (i in 1:10) {\n# p &lt;- p %&gt;% ggtree::rotate(identify(p))\n# print(p)\n# }\n\nRotacione apenas determinados nós-irmãos com a função flip():\n\nggtree(Monocots) + geom_text2(aes(subset = !isTip, label = node)) + geom_tiplab()\n\n\n\n\n\n\n\nflip(ggtree(Monocots), 17, 20) + geom_text2(aes(subset = !isTip, label = node)) + geom_tiplab()\n\n\n\n\n\n\n\n\nColapse nós com função colapse():\n\nggtree(Monocots) + geom_text2(aes(subset = !isTip, label = node), hjust = -.3) + geom_tiplab() + coord_cartesian(xlim = c(0, 10), ylim = c(0, 12))\n\n\n\n\n\n\n\nggtree(Monocots) %&gt;% collapse(17) + geom_text2(aes(subset = !isTip, label = node), hjust = -.3) + geom_tiplab() + coord_cartesian(xlim = c(0, 10), ylim = c(0, 12))\n\n\n\n\n\n\n\n\nIntroduza um símbolo em um nó colapsado:\n\nggtree(Monocots) %&gt;% ggtree::collapse(17) + geom_tiplab() + geom_point2(mapping = aes(subset=(node == 17)), size = 5, shape = 23, fill = \"steelblue\") + geom_tiplab(mapping = aes(subset = (node == 71), label = node), offset = 0.2) + coord_cartesian(xlim = c(0, 10), ylim = c(0, 12))\n\n\n\n\n\n\n\n\nIntroduza um triângulo em 1 nó colapsado com a função geom_polygon() do pacote ggplot2:\n\ntriangle=data.frame(x = c(5, 6, 6), y = c(8, 9, 7))\nggtree(Monocots) %&gt;% ggtree::collapse(17) + geom_tiplab() + geom_polygon(data = triangle, fill = \"darkgray\") + coord_cartesian(xlim = c(0, 10), ylim = c(0, 12))",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Filogenia no R</span>"
    ]
  },
  {
    "objectID": "filogenia-r.html#anotando-dados-na-árvore-usando-r",
    "href": "filogenia-r.html#anotando-dados-na-árvore-usando-r",
    "title": "Filogenia no R",
    "section": "Anotando dados na árvore usando R",
    "text": "Anotando dados na árvore usando R\nDepois de plotar a árvore e alterar seu estilo, personalizando os nomes dos terminais e os ramos (linhas da árvore), vamos aprender a fazer anotações nos nós, ramos e nos terminais, tais como: os valores de suporte dos nós, comprimento dos ramos, plotar símbolos, gráficos de barras, pizzas, etc.\n\nPacote ape\n\nRamos\nAnotando texto nos ramos:\n\nVamos plotar etiquetas e textos nos ramos com a função edgelabels(). Com o argumento frame escolha se incluirá uma caixa de texto com formato circular (“circle”), com ângulos retos (“rect”, default), ou sem caixa de texto (“none”). Com o argumento bg pode alterar a cor de fundo da caixa de texto:\n\n\nplot(plants.tree)\nedgelabels(edge = 29, \"Monilófitas\", cex = 0.8, frame = \"rect\", bg = \"yellow\")\nedgelabels(edge = 21, \"11\", cex = 0.8, frame = \"circle\", bg = \"lightblue\")\nedgelabels(edge = 7, \"Angiospermas\", frame = \"none\", cex = 0.8, adj = c(0.5, -0.5))\n\n\n\n\n\n\n\n\n\nVamos utilizar a árvore na qual plotamos símbolos nos ramos para anotarmos texto sobre eles:\n\n\nplot(plants.tree)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 0)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = -0.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 0.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = -1)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 1)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = -1.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 1.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 2)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 2.5)\n\nedgelabels(edge = 6, 1, cex = 0.5, adj = c(7.3, -0.7), frame = \"none\")\nedgelabels(edge = 6, 2, cex = 0.5, adj = c(5.5, -0.7), frame = \"none\")\nedgelabels(edge = 6, 3, cex = 0.5, adj = c(3.9, -0.7), frame = \"none\")\nedgelabels(edge = 6, 4, cex = 0.5, adj = c(2.3, -0.7), frame = \"none\")\nedgelabels(edge = 6, 5, cex = 0.5, adj = c(0.5, -0.7), frame = \"none\")\nedgelabels(edge = 6, 6, cex = 0.5, adj = c(-1.2, -0.7), frame = \"none\")\nedgelabels(edge = 6, 7, cex = 0.5, adj = c(-2.8, -0.7), frame = \"none\")\nedgelabels(edge = 6, 8, cex = 0.5, adj = c(-4.5, -0.7), frame = \"none\")\nedgelabels(edge = 6, 9, cex = 0.5, adj = c(-6.3, -0.7), frame = \"none\")\n\n\n\n\n\n\n\n\n\nPodemos também escrever um texto inclinado usando o argumento srt:\n\n\nplot(plants.tree)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 0)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = -0.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 0.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = -1)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 1)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = -1.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 1.5)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 2)\nedgelabels(edge = 6, pch = 3, cex = 0.5, adj = 2.5)\nedgelabels(edge = 6, \"Caráter 1\", cex = 0.5, frame = \"none\", adj = c(0.4, -4.5),\n    srt = 55)\nedgelabels(edge = 6, \"Caráter 2\", cex = 0.5, frame = \"none\", adj = c(0.26, -3.5),\n    srt = 55)\nedgelabels(edge = 6, \"Caráter 3\", cex = 0.5, frame = \"none\", adj = c(0.14, -2.6),\n    srt = 55)\nedgelabels(edge = 6, \"Caráter 4\", cex = 0.5, frame = \"none\", adj = c(0, -1.5), srt = 55)\nedgelabels(edge = 6, \"Caráter 5\", cex = 0.5, frame = \"none\", adj = c(-0.15, -0.5),\n    srt = 55)\nedgelabels(edge = 6, \"Caráter 6\", cex = 0.5, frame = \"none\", adj = c(-0.29, 0.54),\n    srt = 55)\nedgelabels(edge = 6, \"Caráter 7\", cex = 0.5, frame = \"none\", adj = c(-0.4, 1.4),\n    srt = 55)\nedgelabels(edge = 6, \"Caráter 8\", cex = 0.5, frame = \"none\", adj = c(-0.53, 2.3),\n    srt = 55)\nedgelabels(edge = 6, \"Caráter 9\", cex = 0.5, frame = \"none\", adj = c(-0.65, 3.2),\n    srt = 55)\n\n\n\n\n\n\n\n\n\n\nTerminais\nAnotando texto nos terminais:\n\nVamos plotar textos nos terminais com a função tiplabels():\n\n\nplot(Monocots, label.offset=1)\ntiplabels()\n\n\n\n\n\n\n\nplot(Monocots, label.offset=1.5)\ntiplabels(\"1\", 1, frame = \"n\", adj=-0.2)\ntiplabels(\"A\", 2, frame = \"n\", adj=-0.2)\ntiplabels(\"teste\", 3, frame = \"n\", adj=-0.2)\n\n\n\n\n\n\n\n\n\nVamos plotar gráficos de barras e pizza nos terminais com os argumentos thermo e pie:\n\n\nplot(Monocots, label.offset = 1)\ntiplabels(pie = runif(11), cex = 1)\n\n\n\n\n\n\n\n\n\n\nNós\nAnotando texto nos nós:\n\nVamos plotar etiquetas e textos nos nós com a função nodelabels():\n\n\nplot(plants.tree)\nnodelabels()\n\n\n\n\n\n\n\nplot(plants.tree)\nnodelabels(\"Tracheophyta\", 28, frame = \"none\")\nnodelabels(\"Angiospermae\", 29, frame = \"n\")\n\n\n\n\n\n\n\n\n\nVamos plotar gráficos de barras e pizza nos nós com os argumentos thermo e pie. Vamos usar a função runif() para gerar números aleatórios de 0 a 1:\n\n\nplot(Monocots)\nnodelabels(thermo = runif(10), cex = 0.7)\n\n\n\n\n\n\n\nplot(Monocots)\nnodelabels(thermo = runif(10), cex = 0.7, horiz = TRUE)\n\n\n\n\n\n\n\nplot(Monocots)\nnodelabels(pie = runif(10), cex = 0.7)\n\n\n\n\n\n\n\n\n\nVamos plotar gráficos de barras e pizza nos nós com mais de duas proporções:\n\n\nprop_x &lt;- runif(22, 0, 0.33)\nprop_y &lt;- runif(22, 0, 0.33)\nprop_z &lt;- runif(22, 0, 0.33)\nprop_w &lt;- cbind(prop_x, prop_y, prop_z, 1 - prop_x - prop_y - prop_z)\nhead(prop_w)\n\n          prop_x     prop_y     prop_z          \n[1,] 0.112698197 0.29041682 0.05352244 0.5433625\n[2,] 0.198436435 0.03611636 0.30012635 0.4653209\n[3,] 0.001042672 0.18015988 0.19385428 0.6249432\n[4,] 0.262839151 0.13313487 0.03364150 0.5703845\n[5,] 0.230191421 0.11745320 0.02044519 0.6319102\n[6,] 0.058252240 0.25142115 0.05569901 0.6346276\n\nlayout(matrix(1:3, 1, 3))\nplot(Monocots, \"c\")\nnodelabels(thermo = prop_w, cex = 1.4)\nplot(Monocots, \"c\")\nnodelabels(thermo = prop_w, cex = 1.4, horiz = TRUE)\nplot(Monocots, \"c\")\nnodelabels(pie = prop_w, cex = 2)\n\n\n\n\n\n\n\n\n\n\n\nPacote phytools\nO pacote phytools não implementa funções específicas para escrever nos terminais e ramos, mas sim para os nós.\n\nNós\nDescubra os números dos nós com o argumento node.numbers:\n\nplotTree(Monocots, node.numbers = TRUE)\n\n\n\n\n\n\n\n\nPlote nomes nos nós:\n\nplotTree(plants.tree)\nlabels &lt;- c(\"Nome1\", \"Nome2\", \"Nome3\")\nlabelnodes(text = labels, node = c(25, 26, 27), shape = \"ellipse\", cex = 0.8,\n    interactive = FALSE)\n\n\n\n\n\n\n\n\nAdicionar nomes aos nós interativamente: (Retire os símbolos # da frente dos comandos)\n\n# plotTree(plants.tree) labelnodes(text = labels, shape = 'ellipse',\n# cex = 0.8, interactive = TRUE)\n\nAdicione nomes aos clados ao lado dos Terminais em árvore do tipo phylogram e cladogram: (Apenas os nós delimitam a chave)\n\nplotTree(plants.tree)\ncladelabels(text = \"Monilófita\", node = 41, offset = 11)\ncladelabels(text = \"Angiospermas\", node = 30, offset = 11)\n\n\n\n\n\n\n\n\nAdicione nomes aos clados ao lado dos terminais em árvore do tipo fan. Com o argumento ylim estabeleça os limites da plotagem:\n\nplotTree(plants.tree, type = \"fan\", fsize = 0.7, ylim = c(-2, 2), offset = 1)\narc.cladelabels(text = \"Gimnospermas\", node = 38, ln.offset = 1.6, lab.offset = 1.8,\n    orientation = \"curved\")\narc.cladelabels(text = \"Angiospermas\", node = 30, ln.offset = 1.8, lab.offset = 2,\n    orientation = \"curved\")\n\n\n\n\n\n\n\n\nAdicionando uma barra de erro nos nós com o método plotTree.errorbars():",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Filogenia no R</span>"
    ]
  },
  {
    "objectID": "filogenia-r.html#plotando-matrizes-data.frames-e-árvore-ao-lado-da-árvore-usando-r",
    "href": "filogenia-r.html#plotando-matrizes-data.frames-e-árvore-ao-lado-da-árvore-usando-r",
    "title": "Filogenia no R",
    "section": "Plotando matrizes, data.frames e árvore ao lado da árvore usando R",
    "text": "Plotando matrizes, data.frames e árvore ao lado da árvore usando R\n…\n\nPacote ape\nO pacote ape possui três funções para plotar matrizes, dataframes, e outra árvore ao lado de uma árvore (tanglegram): phydataplot(), ring() e cophyloplot().\n\nMatriz e data.frame\n\nDados contínuos\nPlote diferentes layouts ao lado da árvore:\n\ndata &lt;- c(2,3,1,2,7,5,4,10,13,12,11)\nnames(data) &lt;- Monocots$tip.label\nplot(Monocots, x.lim = 60)\nphydataplot(data, Monocots, offset = 14)\n\n\n\n\n\n\n\nplot(Monocots, x.lim = 60)\nphydataplot(data, Monocots, offset = 14, col = \"yellow\")\n\n\n\n\n\n\n\nplot(Monocots, x.lim = 60)\nphydataplot(data, Monocots, offset = 14, \"d\")\n\n\n\n\n\n\n\nplot(Monocots, x.lim = 60)\nphydataplot(data, Monocots, offset = 14, \"s\", lwd = 3)\n\n\n\n\n\n\n\n\n\ntx &lt;- rcoal(m &lt;- 20)\nX &lt;- runif(m, 0, 0.5); Y &lt;- runif(m, 0, 0.5)\nX &lt;- cbind(X, Y, 1 - X - Y)\nX\n\n                X          Y          \n [1,] 0.093989531 0.10847785 0.7975326\n [2,] 0.094123294 0.40468965 0.5011871\n [3,] 0.104951279 0.46320230 0.4318464\n [4,] 0.188842487 0.48826657 0.3228909\n [5,] 0.331036230 0.43614703 0.2328167\n [6,] 0.281212370 0.08249638 0.6362913\n [7,] 0.366429595 0.11182848 0.5217419\n [8,] 0.336860853 0.23054090 0.4325982\n [9,] 0.374450226 0.27155537 0.3539944\n[10,] 0.455048915 0.37198909 0.1729620\n[11,] 0.066223075 0.19016757 0.7436094\n[12,] 0.088222494 0.35283877 0.5589387\n[13,] 0.216268655 0.48056114 0.3031702\n[14,] 0.001014687 0.32253413 0.6764512\n[15,] 0.414604950 0.35150316 0.2338919\n[16,] 0.261150199 0.10795476 0.6308950\n[17,] 0.466872645 0.18740064 0.3457267\n[18,] 0.432294984 0.42429373 0.1434113\n[19,] 0.338872901 0.11072074 0.5504064\n[20,] 0.020417431 0.48265081 0.4969318\n\nrownames(X) &lt;- tx$tip.label\nplot(tx, x.lim = 6)\nco &lt;- rgb(diag(3))\nphydataplot(X, tx, col = co)\n\n\n\n\n\n\n\n\n\npar(mar=c(3, 3, 3, 3))\nZ &lt;- matrix(rnorm(m * 5), m)\nrownames(Z) &lt;- rownames(X)\nplot(tx, x.lim = 5)\nphydataplot(Z, tx, \"bo\", scaling = .5, offset = 0.5, boxfill = c(\"gold\", \"skyblue\"))\n\n\n\n\n\n\n\n\n\n\nDados discretos\nPlote uma matriz de diferentes estados para carda caráter com cores diferentes:\n\nc1 &lt;- rep(c(\"estado 1\", \"estado 2\", \"estado 3\"), 10/2)\nnames(c1) &lt;- Monocots$tip.label\nc2 &lt;- rep(c(\"estado 4\", \"estado 5\", \"estado 6\"), 10/2)\nnames(c2) &lt;- Monocots$tip.label\nc3 &lt;- rep(c(\"estado 2\", \"estado 3\", \"estado 4\"), 10/2)\nnames(c3) &lt;- Monocots$tip.label\nmatriz_c &lt;- cbind(c1, c2, c3)\nplot(Monocots, x.lim = 60)\nphydataplot(matriz_c, Monocots, \"m\", width = 2, offset = 14, legend = \"side\")\n\n\n\n\n\n\n\n\n\n\n\nAnéis em árvores circulares\nA função ring() plota dados contínuos e discretos em árvores do tipo “fan”.\n\nDados contínuos\nPlote uma barra de proporções igual a 1:\n\nplot(tx, \"f\", show.tip.label = FALSE, open.angle = 180, x.lim = c(-1, 2), y.lim = c(-2,\n    3.1))\nring(X, tx, col = co, offset = 0.05)\n\n\n\n\n\n\n\n\nPlote mais de um anel de carateres:\n\nts &lt;- rcoal(100)\nX1 &lt;- rTraitCont(ts)\nX2 &lt;- rTraitCont(ts)\nX3 &lt;- rTraitCont(ts)\nco &lt;- c(\"blue\", \"red\")\nX1 &lt;- X1 + abs(min(X1))\nX2 &lt;- X2 + abs(min(X2))\nX3 &lt;- X3 + abs(min(X3))\nop &lt;- par(mar = rep(0, 4))\npar(xpd = TRUE, mar = op$mar)\nplot(ts, \"f\", show.tip.label = FALSE, x.lim = c(-3, 3), y.lim = c(-3, 3),\n    open.angle = 30)\nphydataplot(X1, ts, \"s\", col = co, offset = 0.1, lwd = 5)\nring(X2, ts, \"ring\", col = co, offset = max(X) + 0.3, lwd = 4)\nring(X3, ts, \"ring\", col = co, offset = max(X) + 0.7, lwd = 4)\n\n\n\n\n\n\n\n\n\n\nDados discretos\nPlote duas camadas de anéis:\n\nco &lt;- c(\"lightblue\", \"yellow\")\nco2 &lt;- c(\"lightgreen\", \"lightpink\")\nop &lt;- par(mar = rep(0, 4))\npar(xpd = TRUE, mar = op$mar)\nplot(ts, \"r\", cex = 0.5)\nring(0.1, ts, \"r\", col = sample(co, size = 100, rep = TRUE), offset = 0.3)\nring(0.1, ts, \"r\", col = sample(co2, size = 100, rep = TRUE), offset = 0.5)\n\n\n\n\n\n\n\n\n\n\n\nTanglegram\n\n# Gerar 2 árvores aleatórias com 10 terminais com a função rtree(). As árvores\n# não precisam conter exatamente os mesmos terminais, mas as linhas serão\n# formadas apenas nos terminais com nomes iguais.\ntree1 &lt;- rtree(10)\ntree2 &lt;- rtree(10)\n# Criação de uma matriz de associação:\nassociation &lt;- cbind(tree2$tip.label, tree2$tip.label)\ncophyloplot(tree1, tree2, assoc = association, length.line = 4, space = 28, gap = 3)\n\n\n\n\n\n\n\n# Rotacionar árvore interativamente com argumento rotate: (Retire o # da frente\n# do comando) cophyloplot(tree1, tree2, assoc = association, length.line = 4,\n# space = 28, gap = 3, rotate = TRUE)\n\n\n\n\nPacote phytools\nO pacote phytools possui a função dotTree() e mais três métodos específicos da função plotTree() para plotar círculos, barras, matrizes e boxplots: plotTree.barplot(), plotTree.datamatrix() e plotTree.boxplot():\n\nCírculos\nPlote esferas com tamanho diferenciado de acordo com dados contínuos com a função dotTree():\n\n# Vamos obter a árvore e dados do Blog oficial o pacote Phytools:\ntree &lt;- ape::read.tree(\"http://www.phytools.org/Cordoba2017/data/tree.tre\")\nx &lt;- as.matrix(read.csv(\"http://www.phytools.org/Cordoba2017/data/x.csv\",\n    row.names = 1))[, 1]\n# Agora plote:\ndotTree(tree, x, length = 10, ftype = \"i\")\n\n\n\n\n\n\n\n\nPlote círculos coloridos para representar caracteres discretos:\n\neel.tree &lt;- read.tree(\"http://www.phytools.org/Cordoba2017/data/elopomorph.tre\")\neel.data &lt;- read.csv(\"http://www.phytools.org/Cordoba2017/data/elopomorph.csv\",\n    row.names = 1)\nfmode &lt;- as.factor(setNames(eel.data[, 1], rownames(eel.data)))\ndotTree(eel.tree, fmode, colors = setNames(c(\"blue\", \"red\"), c(\"suction\",\n    \"bite\")), ftype = \"i\", fsize = 0.7)\n\n\n\n\n\n\n\n\n\n\nBarras\nPlote barras com tamanho diferenciado de acordo com dados contínuos com o método plotTree.barplot(). Utilizaremos os mesmos dados obtidos a cima:\n\nplotTree.barplot(tree, x)\n\n\n\n\n\n\n\n\nExperimente colorir as barras do exemplo a cima:\n\nplotTree.barplot(tree, x, args.barplot = list(col = sapply(x, function(x) if (x &gt;=\n    0) \"blue\" else \"red\"), xlim = c(-4, 4)))\n\n\n\n\n\n\n\n\nPlote mais de um caráter: (os objetos tx e X foram usados no exercício do pacote ape)\n\nplotTree.barplot(tx, X)\n\n\n\n\n\n\n\n\nPlote mais de um caráter em barras separadas:\n\nplotTree.barplot(tx, X, args.barplot = list(beside = TRUE, xlim = c(0,\n    1), legend.text = TRUE, space = c(0, 1.2), args.legend = list(x = 1,\n    y = 24)))\n\n\n\n\n\n\n\n\nTeste também uma outra opção implementada no phytools, a o método plotTree.wBars(): [http://blog.phytools.org/2015/04/plottreewbars-with-tip-labels.html]\n\ntip.label &lt;- replicate(200, paste(sample(LETTERS, 1), \"._\", paste(sample(letters,\n    round(runif(n = 1, min = 4, max = 8))), collapse = \"\"), sep = \"\"))\ntree &lt;- pbtree(n = 200, tip.label = tip.label, scale = 1)\nx &lt;- abs(fastBM(tree))\nplotTree.wBars(tree, x, fsize = 0.4, scale = 0.1, tip.labels = TRUE, type = \"fan\",\n    lwd = 1, offset = 1)\n\n\n\n\n\n\n\n\n\n\nMatrizes\nPlote uma matriz com dados discretos com o método plotTree.datamatrix():\n\nlibrary(phytools)\ntree &lt;- rtree(n = 40)\nQ1 &lt;- matrix(c(-1, 1, 1, -1), 2, 2, dimnames = list(0:1, 0:1))\nx1 &lt;- sim.Mk(tree, Q1)\nQ2 &lt;- matrix(c(-1, 1, 0, 1, -2, 1, 0, 1, -1), 3, 3, dimnames = list(letters[1:3],\n    letters[1:3]))\nx2 &lt;- sim.Mk(tree, Q2)\nQ3 &lt;- matrix(c(-0.5, 0.5, 0.5, -0.5), 2, 2, dimnames = list(c(\"rough\",\n    \"smooth\"), c(\"rough\", \"smooth\")))\nx3 &lt;- sim.Mk(tree, Q3)\nQ4 &lt;- matrix(c(-3, 1, 1, 1, 1, -3, 1, 1, 1, 1, -3, 1, 1, 1, 1, -3), 4,\n    4, dimnames = list(LETTERS[1:4], LETTERS[1:4]))\nx4 &lt;- sim.Mk(tree, Q4)\nX &lt;- data.frame(x1, x2, x3, x4)\ncolnames(X) &lt;- c(\"Trait 1\", \"Trait 2\", \"Trait 3\", \"Trait 4\")\nobject &lt;- plotTree.datamatrix(tree, X, sep = 0, srt = 90, yexp = 1.1, xexp = 1.1,\n    fsize = 0.8, space = 0.2)\n\nLoading required package: RColorBrewer\n\n\n\n\n\n\n\n\n\nFaça algumas alterações no estilo da matriz:\n\nobject &lt;- plotTree.datamatrix(tree, X, sep = 0, srt = 70, yexp = 1.05,\n    fsize = 0.8)\nx &lt;- object$end.x + diff(par()$usr[1:2]) * 0.01\ny &lt;- Ntip(tree)\nfor (i in 1:ncol(X)) {\n    text(x, y, colnames(X)[i], pos = 4, cex = 0.9, offset = 0)\n    add.simmap.legend(colors = object$colors[[i]], shape = \"square\", prompt = FALSE,\n        x = x, y = y - 2 * strheight(\"W\") * 0.9, fsize = 0.9)\n    y &lt;- y - 1.5 * 0.9 * strheight(\"W\") * (length(object$colors[[i]]) -\n        1) - 6\n}\n\n\n\n\n\n\n\n\n\n\nBoxplots\n\ntree &lt;- pbtree(n = 26, tip.label = LETTERS[26:1])\n# Simule species means\nx &lt;- fastBM(tree)\n# Simule diferentes amostras de cada terminal (5 por terminal):\nxe &lt;- sampleFrom(x, setNames(rep(0.5, Ntip(tree)), tree$tip.label), setNames(rep(5,\n    Ntip(tree)), tree$tip.label))\nplotTree.boxplot(tree, xe)\n\n\n\n\n\n\n\n\n\n\nTanglegram\nGere duas ávores aleatórias com os mesmos terminais:\n\nt1 &lt;- rtree(n = 20, tip.label = letters[1:20])\nt2 &lt;- rtree(n = 20, tip.label = letters[1:20])\n\nCrie o objeto de classe cophylo com a função de mesmo nome:\n\nobj &lt;- cophylo(t1, t2)\n\nRotating nodes to optimize matching...\nDone.\n\n\nPlote o objeto criado com a função plot.cophylo:\n\nplot.cophylo(obj)\n\n\n\n\n\n\n\n\nAltere parâmetros estéticos com argumentos da função plot.cophylo. Altere a espessura dos ramos da árvore com o argumento lwd. Altere a estética da linha que une os terminais com o argumento link.type = “curved”:\n\nplot.cophylo(obj, lwd = 2, link.type = \"curved\")\n\n\n\n\n\n\n\n\nAltere o tipo de linha com o argumento link.lty:\n\nplot(obj, link.lty = 0)\n\n\n\n\n\n\n\nplot(obj, link.lty = 1)\n\n\n\n\n\n\n\nplot(obj, link.lty = 2)\n\n\n\n\n\n\n\nplot(obj, link.lty = 3)\n\n\n\n\n\n\n\nplot(obj, link.lty = 4)\n\n\n\n\n\n\n\n\nAltere a cor da linha que une os terminais das árvores com o argumento link.col.\n\nplot(obj, link.col = \"red\")\n\n\n\n\n\n\n\n\nAplique uma transparência na cor com a função make.transparent:\n\nplot(obj, link.lwd = 3, link.lty = 1, link.col = make.transparent(\"blue\", 0.25))\n\n\n\n\n\n\n\n\nRetire os pontos do final dos ramos com o argumento pts = FALSE:\n\nplot(obj, pts = FALSE)\n\n\n\n\n\n\n\n\nAltere os pontos do final dos ramos com a método tiplabels.cophylo:\n\nplot(obj)\ntiplabels.cophylo(pie = to.matrix(rep(1, Ntip(obj$trees[[1]])), \"1\"), cex = 0.3,\n    piecol = \"red\")\ntiplabels.cophylo(pie = to.matrix(rep(1, Ntip(obj$trees[[2]])), \"1\"), cex = 0.3,\n    piecol = \"grey\", which = \"right\")\n\n\n\n\n\n\n\n\nRemova os nomes ou altere a fonte dos terminais com o argumento ftype:\n\nplot(obj, ftype = \"off\")\n\n\n\n\n\n\n\nplot(obj, ftype = \"b\")\n\n\n\n\n\n\n\n\nAltere o tamanho da fonte dos terminais com o argumento fsize:\n\nplot(obj, fsize = 1.3)\n\n\n\n\n\n\n\n\nAltere a linha que une a árvore aos terminais. Altere o tipo de linha com o argumento tip.lty (0 = sem linha). Altere a distância entre a árvore e os terminais com o argumento tip.len. Altere a distância entre os terminais de ambas as árvores com o argumento part:\n\nplot(obj, tip.lty = 0, tip.len = 0.05, part = 0.35)\n\n\n\n\n\n\n\n\nAgora veja esse estilo:\n\nplot(obj, link.type = \"curved\", link.lwd = 3, link.lty = 1, lwd = 2,\n    link.col = make.transparent(\"blue\", 0.25), fsize = 1.2)\n\n\n\n\n\n\n\n\n\n\nPhylo.to.map\nConheça a função phylo.to.map() para plotar um mapa com coordenadas geográficas ao lado da árvore. No código abaixo, estamos gerando dados aleatórios:\n\ntree &lt;- pbtree(n = 26, scale = 100)\ntree$tip.label &lt;- LETTERS[26:1]\nlat &lt;- fastBM(tree, sig2 = 10, bounds = c(-90, 90))\nlong &lt;- fastBM(tree, sig2 = 80, bounds = c(-180, 180))\nxx &lt;- phylo.to.map(tree, cbind(lat, long), plot = FALSE)\n\nobjective: 104\nobjective: 104\nobjective: 104\n\n\nobjective: 98\nobjective: 98\nobjective: 98\n\n\nobjective: 96\n\n\nobjective: 94\nobjective: 94\nobjective: 94\n\n\nobjective: 92\n\n\nobjective: 90\n\n\nobjective: 88\nobjective: 88\nobjective: 88\n\n\nobjective: 74\nobjective: 74\n\n\nobjective: 72\nobjective: 72\nobjective: 72\n\n\nobjective: 68\n\n\nobjective: 64\n\n\nobjective: 62\n\n\nobjective: 60\nobjective: 60\n\nplot(xx, type = \"phylogram\", asp = 1.3, mar = c(0.1, 0.5, 3.1, 0.1))\n\n\n\n\n\n\n\n\nVeja um exemplo pronto com dados reais (Fig. @ref{fig:Phylo.to.map}):\n\n\nEscala estratigráfica\nPlote a escala estratigráfica, com dados gerados aleatoriamente, com a função geo.legend() [http://blog.phytools.org/2017/05/new-features-in-geolegend-for-adding.html]:\n\ntree &lt;- pbtree(b = 0.03, d = 0.01, n = 200)\nh &lt;- max(nodeHeights(tree))\n# Primeiro ajuste a legenda sem plotar a árvore:\nplotTree(tree, plot = FALSE)\nobj &lt;- geo.legend(alpha = 0.3, cex = 1.2, plot = T)\n\n\n\n\n\n\n\n# plote a árvore e a legenda estratigráfica:\nplotTree(tree, ftype = \"off\", ylim = c(-0.2*Ntip(tree), Ntip(tree)), lwd = 1)\ngeo.legend(leg = obj$leg, colors = obj$colors, cex = 1.2)",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Filogenia no R</span>"
    ]
  }
]